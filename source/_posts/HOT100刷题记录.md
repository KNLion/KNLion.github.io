---
title: HOT100 刷题记录+复杂度分析+思路
date: 2025-03-05 022:29:06
---
# HOT100
长时间没有刷开始刷题的时候还是蛮难受的

难题汇总

```go
**35.146. LRU 缓存
68.4. 寻找两个正序数组的中位数
73.84. 柱状图中最大的矩形
74.215. 数组中的第K个最大元素**
```

## **A.1.1. 两数之和**

```go
func twoSum(nums []int, target int) []int {
    length := len(nums)
    for i := 0; i < length; i++ {
        for j := i + 1; j < length; j++ {
            if nums[i] + nums[j] == target {
                return []int{i, j}
            }
        }
    }
    return []int{-1, -1}
}
```

> 复杂度分析
时间复杂度：$O(n^2)$ ，其中 n 为 nums 的长度。
空间复杂度：$O(1)$ 。仅用到若干额外变量。
> 

3.min

## **B.2.49. 字母异位词分组**

字符串排序与合并，最后收集，maps.:Values()

```go
func groupAnagrams(strs []string) [][]string {
    m := map[string][]string{}
    for _, s := range strs {
        t := []byte(s)
        slices.Sort(t)
        sortedS := string(t)
        m[sortedS] = append(m[sortedS], s) // sortedS 相同的字符串分到同一组
    }
    return slices.Collect(maps.Values(m))
}

```

> 复杂度分析
时间复杂度：$O(nmlogm)$，其中 n 为 strs 的长度，m 为 strs[i] 的长度。每个字符串排序需要 $O(mlogm)$ 的时间。我们有 n 个字符串，所以总的时间复杂度为 $O(nmlogm)$。
空间复杂度：$O(nm)$。
> 

3.min

## **B.3.128. 最长连续序列**

先生成是否存在的map，然后便利map

```go
func longestConsecutive(nums []int) (ans int) {
    has := map[int]bool{}
    for _, num := range nums {
        has[num] = true // 把 nums 转成哈希集合
    }
    for x := range has {
        if has[x-1] {
            continue
        }
        // x 是序列的起点
        y := x + 1
        for has[y] { // 不断查找下一个数是否在哈希集合中
            y++
        }
        // 循环结束后，y-1 是最后一个在哈希集合中的数
        ans = max(ans, y-x) // 从 x 到 y-1 一共 y-x 个数
    }
    return
}
```

> 复杂度分析
时间复杂度：$O(n)$，其中 n 是 nums 的长度。在二重循环中，每个元素至多遍历两次：在外层循环中遍历一次，在内层循环中遍历一次。所以二重循环的时间复杂度是 $O(n)$ 的。
空间复杂度：$O(n)$。
> 

4.min

## **A.4.283. 移动零**

```go
func moveZeroes(nums []int) {
    left,right := 0,0
    for right<len(nums){
        if nums[right]!=0{
            nums[left],nums[right] = nums[right],nums[left]
            left++
        }        
        right++
    }
}

```

> 复杂度分析
时间复杂度: $O(n)$，其中 n 为 nums 的长度。
空间复杂度: $O(1)$，仅使用了常数个变量。
> 

## **A.5.11. 盛最多水的容器**

```go
func maxArea(height []int) (ans int) {
    left, right := 0, len(height)-1
    for left < right {
        area := (right - left) * min(height[left], height[right])
        ans = max(ans, area)
        if height[left] < height[right] {
            left++
        } else {
            right--
        }
    }
    return
}

```

> 复杂度分析
时间复杂度：O(n)，其中 n 为 height 的长度。
空间复杂度：O(1)，仅用到若干额外变量。
> 

## **C.6.15. 三数之和***

错了好多遍了，后面两个指针的移动规律要搞清楚，先移动第三个，还要确定没有重复的

```go
func threeSum(nums []int) [][]int {
    n := len(nums)
    sort.Ints(nums)
    ans := make([][]int, 0)
 

    for first := 0; first < n; first++ {
        
        if first > 0 && nums[first] == nums[first - 1] {
            continue
        }
        
        third := n - 1
        target := -1 * nums[first]
        
        for second := first + 1; second < n; second++ {
            
            if second > first + 1 && nums[second] == nums[second - 1] {
                continue
            }
            
            for second < third && nums[second] + nums[third] > target {
                third--
            }

            if second == third {
                break
            }
            if nums[second] + nums[third] == target {
                ans = append(ans, []int{nums[first], nums[second], nums[third]})
            }
        }
    }
    return ans
}

```

> 复杂度分析
时间复杂度：$O(N^2)$，其中 N 是数组 nums 的长度。
空间复杂度：$O(logN)$。我们忽略存储答案的空间，额外的排序的空间复杂度为 $O(logN)$。然而我们修改了输入的数组 nums，在实际情况下不一定允许，因此也可以看成使用了一个额外的数组存储了 nums 的副本并进行排序，空间复杂度为 $O(N)$。
> 

## **A.7.42. 接雨水**

```go
func trap(height []int)(ans int ){
    left,right,perMax,sufMax := 0,len(height)-1,0,0
    for left<right{
        perMax = max(perMax,height[left])
        sufMax = max(sufMax,height[right])
        if height[left]< height[right]{
            ans+= perMax-height[left]
            left++
        }else{
            ans+= sufMax-height[right]
            right--
        }
    }
    return ans
}
```

> 复杂度分析
时间复杂度：O(n)，其中 n 为 height 的长度。
空间复杂度：O(1)，仅用到若干额外变量。
> 

## **A.8.3. 无重复字符的最长子串**

双指针

```go
func lengthOfLongestSubstring(s string) int {
    left,max_l:=0,0
    m := map[byte]bool{}
    for right,_:= range s{
        for m[s[right]] {
            m[s[left]]=false
            left++
        }
        m[s[right]]=true
        max_l = max(max_l,right-left+1)

    }
    return max_l

}
```

> 复杂度分析
时间复杂度：$O(n)$，其中 n 为 s 的长度。注意 left 至多增加 n 次，所以整个二重循环至多循环 $O(n)$ 次。
空间复杂度：$O(∣Σ∣)$，其中 $∣Σ∣$ 为字符集合的大小，本题中字符均为 ASCII 字符，所以 $∣Σ∣≤128$。
> 

## **A.9.438. 找到字符串中所有字母异位词**

使用数组来判定真是天才

```go
func findAnagrams(s string, p string)(ans []int){
    cntP := [26]int{}
    cntS := [26]int{}
    for _,c := range p{
        cntP[c-'a']++
    }
    for right,c := range s{
        cntS[c-'a']++
        left := right - len(p) +1
        if left <0 {
            continue
        }
        if cntS == cntP{
            ans = append(ans,left)
        }
        cntS[s[left]-'a']--

    }
    return 
}
```

> 复杂度分析
时间复杂度：O(∣Σ∣m+n)，其中 m 是 s 的长度，n 是 p 的长度，∣Σ∣=26 是字符集合的大小。
空间复杂度：O(∣Σ∣)。返回值不计入。
> 

## **B.10.560. 和为 K 的子数组**

前缀和，查找的时候，使用map，时间复杂度底一点

```go
func subarraySum(nums []int, k int) (ans int) {
    s:=0
    m:= map[int]int{0:1}
    for _,v := range nums{
        s += v
        ans += m[s-k]
        m[s]++
    }
    return ans
}

```

> 复杂度分析
时间复杂度：O(n)，其中 n 为 nums 的长度。
空间复杂度：O(m)，其中 m 为 s 中的不同元素个数。如果像 Java 那样设置了哈希表的容量，则空间复杂度为 O(n)。
> 

## **C.11.239. 滑动窗口最大值**

单调队列，但是还要判定清楚上下界

```go
func maxSlidingWindow(nums []int, k int) []int {
    ans := make([]int, 0, len(nums)-k+1) // 预先分配好空间
    q := []int{}
    for i, x := range nums {
        // 1. x入队的时候,弹出所有比x小的元素， 
        for len(q) > 0 && nums[q[len(q)-1]] <= x {
            q = q[:len(q)-1] // 维护x的单调性，
        }
        q = append(q, i) // 入队
        // 2. 出 判断是否要出栈
        if i-q[0] >= k { // 队首已经离开窗口了，因为记录的是i ，可以根据i 推断出是否要出栈，
            q = q[1:] // Go 的切片是 O(1) 的
        }
        // 3. 记录答案
        if i >= k-1 {
            // 由于队首到队尾单调递减，所以窗口最大值就是队首
            ans = append(ans, nums[q[0]])
        }
    }
    return ans
}

```

## **C.12.76. 最小覆盖子串**

3刷失败，需要专门的函数来判定是否覆盖，再决定是否移动窗口

```go
func isCovered(cntS, cntT []int) bool {
    for i := 'A'; i <= 'Z'; i++ {
        if cntS[i] < cntT[i] {
            return false
        }
    }
    for i := 'a'; i <= 'z'; i++ {
        if cntS[i] < cntT[i] {
            return false
        }
    }
    return true
}

func minWindow(s, t string) string {
    ansLeft, ansRight := -1, len(s)
    var cntS, cntT [128]int
    for _, c := range t {
        cntT[c]++
    }

    left := 0
    for right, c := range s { // 移动子串右端点
        cntS[c]++ // 右端点字母移入子串
        for isCovered(cntS[:], cntT[:]) { // 涵盖
            if right-left < ansRight-ansLeft { // 找到更短的子串
                ansLeft, ansRight = left, right // 记录此时的左右端点
            }
            cntS[s[left]]-- // 左端点字母移出子串
            left++
        }
    }
    if ansLeft < 0 {
        return ""
    }
    return s[ansLeft : ansRight+1]
}

```

> 复杂度分析
时间复杂度：$O(∣Σ∣m+n)$，其中 m 为 s 的长度，n 为 t 的长度，∣Σ∣ 为字符集合的大小，本题字符均为英文字母，所以 $∣Σ∣=52$。注意 left 只会增加不会减少，left 每增加一次，我们就花费 O(∣Σ∣) 的时间。因为 left 至多增加 m 次，所以二重循环的时间复杂度为 O(∣Σ∣m)，再算上统计 t 字母出现次数的时间 $O(n)$，总的时间复杂度为 $O(∣Σ∣m+n)$。
空间复杂度：$O(∣Σ∣)$。如果创建了大小为 128 的数组，则 $∣Σ∣=128$。
> 

## **C.13.53. 最大子数组和**

这一题应该使用dp，转移方程，取包含第i位的最大值，不包含第i位的最大值

```go
func maxSubArray(nums []int) int {
    dp := make([]int, len(nums))
    dp[0] = nums[0]
    for i := 1; i < len(nums); i++ {
        dp[i] = max(dp[i-1], 0) + nums[i]
    }
    return slices.Max(dp)
}

```

> 复杂度分析
时间复杂度：$O(n)$，其中 n 为 nums 的长度。
空间复杂度：$O(n)$。仅用到若干额外变量。
> 

## **B.14.56. 合并区间**

可以适当加速，做了3遍了

记住 slices.SortFunc 的使用方法，返回值是 int 两者的差值，记录

```go
func merge(intervals [][]int) [][]int {
    slices.SortFunc(intervals,func(a,b []int)int {return a[0]-b[0]})
    res := [][]int{}
    for _,v:= range intervals {
        if len(res)==0 || v[0]>res[len(res)-1][1]{
            res = append(res,v)
        }else{
            res[len(res)-1][1] = max(res[len(res)-1][1],v[1])
        }
    }
    return res
}
```

> 复杂度分析
时间复杂度：$O(nlogn)$，其中 n 是 intervals 的长度。瓶颈在排序上。
空间复杂度：$O(1)$。排序的栈开销和返回值不计入。
> 

## **A.15.189. 轮转数组**

记一下 翻转函数，slices.Reverse(nums)

```go
func rotate(nums []int, k int)  {
    k%= len(nums)
    slices.Reverse(nums)
    slices.Reverse(nums[:k])
    slices.Reverse(nums[k:])
}
```

> 复杂度分析
时间复杂度：$O(n)$，其中 n 是 nums 的长度。
空间复杂度：$O(1)$。
> 

## **A.16.238. 除自身以外数组的乘积**

```go
func productExceptSelf(nums []int) []int {
    n := len(nums)
    suf := make([]int, n)
    suf[n-1] = 1
    for i := n - 2; i >= 0; i-- {
        suf[i] = suf[i+1] * nums[i+1]
    }

    pre := 1
    for i, x := range nums {
        // 此时 pre 为 nums[0] 到 nums[i-1] 的乘积，直接乘到 suf[i] 中
        suf[i] *= pre
        pre *= x
    }

    return suf
}
 
```

> 复杂度分析
时间复杂度：$O(n)$，其中 n 是 nums 的长度。
空间复杂度：$O(1)$。返回值不计入。
> 

## **B.17.41. 缺失的第一个正数**

要有一个abs 来 获取正确的数字，先把负数和0 都重置为 n+1

```go
func firstMissingPositive(nums []int)(ans int ){
    n := len(nums)
    for i,v := range nums{
        if v < 1{
            nums[i] = n+1
        }
    }
    for _,v := range nums{
        v=abs(v)
        if v <= n{
            nums[v-1] = -abs(nums[v-1])
        }
    }
    for i,v := range nums{
        if v>0 {
           return i+1
        }
    }
    return n+1
}

func abs(x int) int {
    if x < 0 {
        return -x
    }
    return x
}
```

> 复杂度分析
时间复杂度：$O(N)$，其中 $N$ 是数组的长度。
空间复杂度：$O(1)$。
> 

## **B.18.73. 矩阵置零**

因为根据 m[i][0] 和 m[0][j] 判断m[i][j] 是否置0，

```go
func setZeroes(matrix [][]int) {
    n, m := len(matrix), len(matrix[0])
    row0, col0 := false, false
    for _, v := range matrix[0] {
        if v == 0 {
            row0 = true
            break
        }
    }
    for _, r := range matrix {
        if r[0] == 0 {
            col0 = true
            break
        }
    }
    for i := 1; i < n; i++ {
        for j := 1; j < m; j++ {
            if matrix[i][j] == 0 {
                matrix[i][0] = 0
                matrix[0][j] = 0
            }
        }
    }
    for i := 1; i < n; i++ {
        for j := 1; j < m; j++ {
            if matrix[i][0] == 0 || matrix[0][j] == 0 {
                matrix[i][j] = 0
            }
        }
    }
    if row0 {
        for j := 0; j < m; j++ {
            matrix[0][j] = 0
        }
    }
    if col0 {
        for _, r := range matrix {
            r[0] = 0
        }
    }
}

```

## **C.19.54. 螺旋矩阵**

最上面，右下左上算清楚，然后转向只要一次就行，先放入ans 再 找x,y的next

走m*n步，每次到达边界，或者 已经访问过的数据，就右转90度，

```go
var dirs = [4][2]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}} // 右下左上

func spiralOrder(matrix [][]int) []int {
    m, n := len(matrix), len(matrix[0])
    ans := make([]int, m*n)
    i, j, di := 0, 0, 0
    for k := range ans { // 一共走 mn 步
        ans[k] = matrix[i][j]
        matrix[i][j] = math.MaxInt // 标记，表示已经访问过（已经加入答案）
        x, y := i+dirs[di][0], j+dirs[di][1] // 下一步的位置
        // 如果 (x, y) 出界或者已经访问过
        if x < 0 || x >= m || y < 0 || y >= n || matrix[x][y] == math.MaxInt {
            di = (di + 1) % 4 // 右转 90°
        }
        i += dirs[di][0]
        j += dirs[di][1] // 走一步
    }
    return ans
}

```

> 复杂度分析
时间复杂度：$O(mn)$，其中 m 和 n 分别为 matrix 的行数和列数。
空间复杂度：$O(1)$。返回值不计入。
> 

## **A.20.48. 旋转图像**

先上下翻转，然后对角线翻转，达到90度翻转，

```go
func rotate(matrix [][]int)  {
    n:= len(matrix)
    for i:=0;i<n/2;i++{
        matrix[i],matrix[n-1-i] = matrix[n-1-i],matrix[i]
    }

    for i:=0;i<n;i++{
        for j:=0;j<i;j++{
            matrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j]
        }

    }

}
```

> 复杂度分析
时间复杂度：$O(N^2)$，其中 N 是 matrix 的边长。对于每一次翻转操作，我们都需要枚举矩阵中一半的元素。
空间复杂度：$O(1)$。为原地翻转得到的原地旋转。
> 

## **A.21.240. 搜索二维矩阵 II**

从右上角开始找，如果过大，左移，如果过小，下移

```go
func searchMatrix(matrix [][]int, target int) bool {
    m, n := len(matrix), len(matrix[0])
    i, j := 0, n-1 // 从右上角开始
    for i < m && j >= 0 { // 还有剩余元素
        if matrix[i][j] == target {
            return true // 找到 target
        }
        if matrix[i][j] < target {
            i++ // 这一行剩余元素全部小于 target，排除
        } else {
            j-- // 这一列剩余元素全部大于 target，排除
        }
    }
    return false
}
```

> 复杂度分析
时间复杂度：$O(m+n)$，其中 m 和 n 分别为 matrix 的行数和列数。
空间复杂度：$O(1)$。
> 

## **B.22.160. 相交链表**

2种方法，1种统计长度，然后获取目标，

访问一个链表之后，在访问另一个链表，无论哪个，访问的长度都是一样的，进度会匹配，

```go
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    p,q := headA,headB
    for p!=q{
        if p!=nil{
            p = p.Next
        } else {
            p = headB
        }

        if q !=nil{
            q = q.Next
        }else{
            q = headA
        }
    }
    return p
}
```

> 复杂度分析
时间复杂度：$O(m+n)$，其中 m 是第一条链表的长度，n 是第二条链表的长度。除了交点，每个节点会被指针 p 访问至多一次，每个节点会被指针 q 访问至多一次。
空间复杂度：$O(1)$。
> 

## **A.23.206. 反转链表**

很有用的代码片段，开头要，pre，cur两个指针，循环的时候要个next指针，不停把cur挂靠在pre上

```go
func reverseList(head *ListNode) *ListNode {
    var pre,cur *ListNode = nil,head
    for cur != nil{
        next := cur.Next
        cur.Next = pre
        pre = cur
        cur = next
    }
    return pre
}
```

> 复杂度分析
时间复杂度：O(n)，其中 n 为链表节点个数。
空间复杂度：O(1)，仅用到若干额外变量。
> 

## **C.24.234. 回文链表**

翻转链表那里没写对

找到中间节点，翻转，然后两个指针，一个从头开始，一个中间开始，对比

```go
func middleNode(head *ListNode) *ListNode {
    slow,fast := head ,head 
    for fast != nil && fast.Next != nil{
        fast = fast.Next.Next
        slow = slow.Next
    }
    return slow
}

func reverseList(head *ListNode) *ListNode{
    var pre ,cur *ListNode = nil,head
    for cur!= nil{
        next := cur.Next
        cur.Next= pre
        pre = cur
        cur = next
    }
    return pre
}

func isPalindrome(head *ListNode) bool {
    middle := middleNode(head)
    head2 := reverseList(middle)
    for head2!= nil{
        if head.Val != head2.Val{
            return false
        }
        head = head.Next
        head2 = head2.Next
    }
    return true
}
```

> 复杂度分析
时间复杂度：$O(n)$，其中 $n$ 是链表的长度（节点个数）。
空间复杂度：$O(1)$。
> 

## **A.25.141. 环形链表**

快慢指针，两个不同速度的指针，只要有环路，一定会相遇

```go
func hasCycle(head *ListNode) bool {
    slow := head
    fast := head
    for fast != nil && fast.Next != nil{
        slow = slow.Next
        fast = fast.Next.Next

        if slow == fast{
            return true
        }
    }
    return false
}
```

> 复杂度分析
时间复杂度: O(n)，其中 n 为链表的长度。
空间复杂度: O(1)，其中 n 为链表的长度，我们仅使用了常数个变量。
> 

## **B.26.142. 环形链表 II**

要有一个判断终止条件的，先判断有没有环

快慢指针相遇后，走过的距离slow =x  fast=2x ，环前为a，环为b，2x-x=nb

```go
func detectCycle(head *ListNode) *ListNode {
    fast,slow := head,head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if fast == slow {
            for slow != head{
                slow = slow.Next
                head = head.Next
            }
            return slow
        }
    }
    return nil
}
```

> 复杂度分析
时间复杂度：O(n)，其中 n 为链表的长度。
空间复杂度：O(1)，仅用到若干额外变量。
> 

## **A.27.21. 合并两个有序链表**

开头使用哨兵节点，两个链表谁小先连接上，然后下一位，最后把剩下的连接上，

```go
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    sentinel := &ListNode{}
    cur := sentinel
    for list1 != nil && list2 != nil {
        if list1.Val < list2.Val{
            cur.Next = list1
            list1 = list1.Next
        }else{
            cur.Next = list2
            list2 = list2.Next    
        }
        cur = cur.Next
    }

    if list1 != nil {
        cur.Next = list1
    }else{
        cur.Next = list2
    }
    return sentinel.Next
}
```

> 复杂度分析
时间复杂度：O(n+m)，其中 n 为 list 1的长度，m 为 list 2的长度。
空间复杂度：O(1)。仅用到若干额外变量。
> 

## **A.28.2. 两数相加**

用链表存储数字，然后使用新链表，存储和，然后溢出数

```go
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    sentinel := ListNode{}
    cur := &sentinel
    carry := 0
    for l1 != nil || l2 != nil || carry != 0{
        if l1 !=nil{
            carry+= l1.Val
            l1 = l1.Next
        }
        if l2 !=nil{
            carry+= l2.Val
            l2 = l2.Next
        }
        cur.Next = &ListNode{Val: carry%10 }
        cur = cur.Next
        carry/=10
    }
    return sentinel.Next

}
```

> 复杂度分析
时间复杂度：O(n)，其中 n 为l1长度和 l2长度的最大值。
空间复杂度：O(1)。返回值不计入。
> 

## **A.29.19. 删除链表的倒数第 N 个结点**

双指针，A,B 当B指针移动到第n个位置的时候，A指针开始移动，B到最后一个节点的时候，删除A

```go
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    sentinel := ListNode{Next:head}
    left,right := &sentinel,&sentinel
    for ;n>0;n--{
        right=right.Next
    }
    for right.Next != nil {
        left = left.Next
        right = right.Next
    }
    left.Next = left.Next.Next
    return sentinel.Next
}
```

> 复杂度分析
时间复杂度：O(m)，其中 m 为链表的长度。
空间复杂度：O(1)，仅用到若干额外变量。
> 

## **A.30.24. 两两交换链表中的节点**

k个数组翻转 当k等于2 的情况，

```go
func swapPairs(head *ListNode) *ListNode {
    sentinel := ListNode{Next:head}
    node0 := &sentinel
    node1 := head
    for node1 != nil && node1.Next != nil {
        node2 := node1.Next
        node3 := node2.Next

        node0.Next = node2
        node2.Next = node1
        node1.Next = node3

        node0 = node1
        node1 = node3
    }

    return sentinel.Next

}

```

> 复杂度分析
时间复杂度：O(n)，其中 n 为链表长度。
空间复杂度：O(1)。仅用到若干额外变量。
> 

## **B.31.25. K 个一组翻转链表**

计算长度，分段，翻转函数，链接

```go
func reverseKGroup(head *ListNode, k int) *ListNode {
    // 计算链表长度
    n := 0
    for cur := head; cur != nil; cur = cur.Next {
        n++
    }

    // 哨兵节点，方便处理头节点的变化
    sentinel := &ListNode{Next: head}
    prevGroup := sentinel

    // 定义翻转函数
    reverse := func(start *ListNode, k int) (*ListNode, *ListNode) {
        var prev, cur *ListNode = nil, start
        for i := 0; i < k; i++ {
            next := cur.Next
            cur.Next = prev
            prev = cur
            cur = next
        }
        return prev, start // 返回翻转后的新头和尾
    }

    for ; n >= k; n -= k {
        start := prevGroup.Next
        end := start
        for i := 0; i < k-1; i++ { // 找到这组的最后一个节点
            end = end.Next
        }
        nextGroup := end.Next
        // 翻转当前组
        newHead, newTail := reverse(start, k)
        // 连接翻转后的链表
        prevGroup.Next = newHead
        newTail.Next = nextGroup
        prevGroup = newTail
    }

    return sentinel.Next
}

```

> 复杂度分析
时间复杂度：O(n)，其中 n 为链表节点个数。
空间复杂度：O(1)，仅用到若干额外变量。
> 

## **C.32.138. 随机链表的复制**

最后边界处理的时候，A→A1→nil 单独处理

A,B,C, 变成 A,A1,B,B1,C,C1,然后 间隔遍历cur.Next.Random = cur.Random.Next，最后分离链表，

```go
func copyRandomList(head *Node) *Node {
    if head == nil {
        return nil
    }

    for cur := head;cur != nil;cur = cur.Next.Next{
        cur.Next = &Node{Val:cur.Val,Next:cur.Next}
    }

    for cur := head;cur != nil ; cur = cur.Next.Next{
        if cur.Random != nil{
            cur.Next.Random = cur.Random.Next
        }
    }

    newHead := head.Next
    cur := head
    for ;cur.Next.Next != nil ;cur = cur.Next{
        clone := cur.Next
        cur.Next = cur.Next.Next
        clone.Next = clone.Next.Next
    }
    cur.Next = nil
    return newHead
}

```

> 复杂度分析
时间复杂度：O(n)，其中 n 是链表的长度。
空间复杂度：O(1)。返回值不计入。
> 

## **C.33.148. 排序链表**

终止条件确定清楚，每一次

使用归并排序，均分2段，分到底，然后合并链表

```go
func sortList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head // 空链表或只有一个节点，直接返回
    }

    // 1. 使用快慢指针找到链表的中点
    mid := findMiddle(head)
    right := mid.Next
    mid.Next = nil // 切断链表

    // 2. 递归排序左右两部分
    left := sortList(head)
    right = sortList(right)

    // 3. 合并两个排序好的链表
    return mergeTwoLists(left, right)
}

// 快慢指针找到链表中点
func findMiddle(head *ListNode) *ListNode {
    slow, fast := head, head
    for fast.Next != nil && fast.Next.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }
    return slow
}

// 合并两个有序链表
func mergeTwoLists(list1, list2 *ListNode) *ListNode {
    sentinel := &ListNode{}
    cur := sentinel// 哨兵节点
    for list1 != nil && list2 != nil {
        if list1.Val < list2.Val{
            cur.Next = list1
            list1 = list1.Next
        }else{
            cur.Next = list2
            list2 = list2.Next    
        }
        cur = cur.Next
    }
    // 将剩余节点接到结果链表后
    if list1 != nil {
        cur.Next = list1
    }else{
        cur.Next = list2
    }
    return sentinel.Next
}

```

> 复杂度分析
时间复杂度：$O(nlogn)$，其中 n 是链表长度。递归式 $T(n)=2T(n/2)+O(n)$，由主定理可得时间复杂度为 $O(nlogn)$ 。
空间复杂度：$O(logn)$。递归需要 $O(logn)$ 的栈开销 。
> 

## **C.34.23. 合并 K 个升序链表**

必须再学习学习，堆的使用，heap 的使用，

小顶堆，优先队列，放队列,堆化，然后处理链表，比较难 的是堆实现

```go
func mergeKLists(lists []*ListNode) *ListNode {
    h := hp{}
    for _, head := range lists {
        if head != nil {
            h = append(h, head)
        }
    }
    heap.Init(&h) // 堆化

    dummy := &ListNode{} // 哨兵节点，作为合并后链表头节点的前一个节点
    cur := dummy
    for len(h) > 0 { // 循环直到堆为空
        node := heap.Pop(&h).(*ListNode) // 剩余节点中的最小节点
        if node.Next != nil { // 下一个节点不为空
            heap.Push(&h, node.Next) // 下一个节点有可能是最小节点，入堆
        }
        cur.Next = node // 合并到新链表中
        cur = cur.Next // 准备合并下一个节点
    }
    return dummy.Next // 哨兵节点的下一个节点就是新链表的头节点
}

type hp []*ListNode
func (h hp) Len() int         { return len(h) }
func (h hp) Less(i, j int)bool{ return h[i].Val < h[j].Val } // 最小堆
func (h hp) Swap(i, j int)    { h[i], h[j] = h[j], h[i] }
func (h *hp) Push(v any)      { *h = append(*h, v.(*ListNode)) }
func (h *hp) Pop() any        { a := *h; v := a[len(a)-1]; *h = a[:len(a)-1]; return v }

```

> 复杂度分析
时间复杂度：O(nlogk)，其中 k 为 lists 的长度，n 为所有链表的节点数之和。
空间复杂度：O(k)。堆中至多有 k 个元素。
> 

## **C.35.146. LRU 缓存 ***

耗时非常久，要好好处理，学习清楚怎么做

这个直接默写吧，可以先学习一下简单写法

```go
/*
键值都为 int

size
cap
head ,tail
cache 

头尾2个空节点

add to head
和 
move to head (多了一个删除)
分清楚

记得加入节点 
*/

type LRUCache struct {
    size int
    capacity int
    cache map[int]*DLinkedNode
    head, tail *DLinkedNode
}

type DLinkedNode struct {
    key, value int
    prev, next *DLinkedNode
}

func initDLinkedNode(key, value int) *DLinkedNode {
    return &DLinkedNode{
        key: key,
        value: value,
    }
}

func Constructor(capacity int) LRUCache {
    l := LRUCache{
        cache: map[int]*DLinkedNode{},
        head: initDLinkedNode(0, 0),
        tail: initDLinkedNode(0, 0),
        capacity: capacity,
    }
    l.head.next = l.tail
    l.tail.prev = l.head
    return l
}

func (this *LRUCache) Get(key int) int {
    if _, ok := this.cache[key]; !ok {
        return -1
    }
    node := this.cache[key]
    this.moveToHead(node)
    return node.value
}

func (this *LRUCache) Put(key int, value int)  {
    if _, ok := this.cache[key]; !ok {
        node := initDLinkedNode(key, value)
        this.cache[key] = node
        this.addToHead(node)
        this.size++
        if this.size > this.capacity {
            removed := this.removeTail()
            delete(this.cache, removed.key)
            this.size--
        }
    } else {
        node := this.cache[key]
        node.value = value
        this.moveToHead(node)
    }
}

func (this *LRUCache) addToHead(node *DLinkedNode) {
    node.prev = this.head
    node.next = this.head.next
    this.head.next.prev = node
    this.head.next = node
}

func (this *LRUCache) removeNode(node *DLinkedNode) {
    node.prev.next = node.next
    node.next.prev = node.prev
}

func (this *LRUCache) moveToHead(node *DLinkedNode) {
    this.removeNode(node)
    this.addToHead(node)
}

func (this *LRUCache) removeTail() *DLinkedNode {
    node := this.tail.prev
    this.removeNode(node)
    return node
}

```

> 复杂度分析
时间复杂度：对于 put 和 get 都是 **O(1)** 。
空间复杂度：**O(capacity)**，因为哈希表和双向链表最多存储 capacity+1 个元素。
> 

### 简洁代码

```go
type entry struct {
    key, value int
}

type LRUCache struct {
    capacity  int
    list      *list.List // 双向链表
    keyToNode map[int]*list.Element
}

func Constructor(capacity int) LRUCache {
    return LRUCache{capacity, list.New(), map[int]*list.Element{}}
}

func (c *LRUCache) Get(key int) int {
    node := c.keyToNode[key]
    if node == nil { // 没有这本书
        return -1
    }
    c.list.MoveToFront(node) // 把这本书放在最上面
    return node.Value.(entry).value
}

func (c *LRUCache) Put(key, value int) {
    if node := c.keyToNode[key]; node != nil { // 有这本书
        node.Value = entry{key, value} // 更新
        c.list.MoveToFront(node) // 把这本书放在最上面
        return
    }
    c.keyToNode[key] = c.list.PushFront(entry{key, value}) // 新书，放在最上面
    if len(c.keyToNode) > c.capacity { // 书太多了
        delete(c.keyToNode, c.list.Remove(c.list.Back()).(entry).key) // 去掉最后一本书
    }
}

```

## **B.36.94. 二叉树的中序遍历**

函数内部声明函数

递归方法，快速实现

```go
func inorderTraversal(root *TreeNode) (res []int) {
    ans := []int{}
    var traversal func(node *TreeNode)
    traversal = func(node *TreeNode){
        if node == nil{return}
        traversal(node.Left)
        ans = append(ans,node.Val)
        traversal(node.Right)
    }
    traversal(root)
    return ans
}
```

> 复杂度分析
时间复杂度：$O(n)$，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。
空间复杂度：$O(n)$。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 $O(n)$ 的级别。
> 

## **B.37.104. 二叉树的最大深度**

层序遍历，找到最大深度

```go
func maxDepth(root *TreeNode) int {
    depth := 0
    ans := []int{-1}
    var order func(node *TreeNode,depth int)
    order = func(node *TreeNode,depth int){
        if node == nil{return}
        ans[0] = max(ans[0],depth)
        order(node.Left,depth+1)
        order(node.Right,depth+1)
    }
    order(root,depth)
    return ans[0]+1
}
```

> 复杂度分析
时间复杂度：$O(n)$，其中 n 为二叉树的节点个数。
空间复杂度：$O(n)$。最坏情况下，二叉树退化成一条链，递归需要 $O(n)$ 的栈空间。
> 

## **B.38.226. 翻转二叉树**

递归翻转

```go
func invertTree(root *TreeNode) *TreeNode {
    if root == nil{return nil}
    root.Left,root.Right = root.Right,root.Left
    invertTree(root.Left)
    invertTree(root.Right)
    return root
}
```

> 复杂度分析
时间复杂度：$O(n)$，其中 n 为二叉树的节点个数。
空间复杂度：$O(n)$。最坏情况下，二叉树退化成一条链，递归需要 $O(n)$ 的栈空间。
> 

## **C.39.101. 对称二叉树**

要改造递归方法

技巧性判断两个节点是否同时为空，

```go
func isSymmetric(root *TreeNode) bool {
    var bfs func(L *TreeNode,R *TreeNode) bool
    bfs = func(L *TreeNode,R *TreeNode) bool {
        if L == nil || R == nil {return L==R}
        return L.Val == R.Val && bfs(L.Left,R.Right) && bfs(L.Right,R.Left) 
    }
    if root == nil {return true}
    return bfs(root.Left,root.Right)
}
```

> 复杂度分析
时间复杂度：$O(n)$，其中 n 为二叉树的节点个数。
空间复杂度：$O(n)$。最坏情况下，二叉树退化成一条链，递归需要 $O(n)$ 的栈空间。
> 

## **A.40.543. 二叉树的直径**

要有个全局变量找max，

```go
func diameterOfBinaryTree(root *TreeNode) int {
    ans := []int{-1}

    var dfs func(node *TreeNode)int
    dfs = func(node *TreeNode)int{
        if node == nil{return 0}
        L,R := dfs(node.Left),dfs(node.Right)
        // fmt.Println(L,R)
        ans[0] = max(ans[0],L+1+R)
        return max(L+1,R+1)
    }
    dfs(root)
    return ans[0]-1
}
```

> 复杂度分析
时间复杂度：O(n)，其中 n 为二叉树的节点个数。
空间复杂度：O(n)。最坏情况下，二叉树退化成一条链，递归需要 O(n) 的栈空间。
> 

## **A.41.102. 二叉树的层序遍历**

使用递归方法，有一个depth 确定深度，和插入位置

```go
func levelOrder(root *TreeNode) [][]int {
    arr := [][]int{}
    depth:=0
    var order func(node *TreeNode,depth int)
    order = func(node *TreeNode,depth int){
        if node == nil{return}
        if len(arr) == depth{arr = append(arr,[]int{})}
        arr[depth] = append(arr[depth],node.Val)
        order(node.Left,depth+1)
        order(node.Right,depth+1)
    }
    order(root,depth)
    return arr
}
```

> 复杂度分析
时间复杂度：$O(n)$，其中 n 为二叉树的节点个数。
空间复杂度：$O(n)$。满二叉树（每一层都填满）最后一层有大约 n/2 个节点，因此函数栈最多有 $O(n)$ 个元素，所以空间复杂度是 O(n) 的。
> 

## **A.42.108. 将有序数组转换为二叉搜索树**

递归真的很棒，简洁而优美

```go
func sortedArrayToBST(nums []int) *TreeNode {
    if len(nums)==0 {return nil}
    m:=len(nums)/2
    return &TreeNode{
        Val:nums[m],
        Left:sortedArrayToBST(nums[:m]),
        Right:sortedArrayToBST(nums[m+1:]),
    }
}
```

> 复杂度分析
时间复杂度：O(n)，其中 n 是 nums 的长度。每次递归要么返回空节点，要么把 nums 的一个数转成一个节点，所以递归次数是 O(n) 的，所以时间复杂度是 O(n)。
空间复杂度：O(n)切片传值，不会复制所有元素。
> 

## **A.43.98. 验证二叉搜索树**

传入上下限，math.MaxInt64

```go
func isValidBST(root *TreeNode) bool {
    var dfs func(node *TreeNode,lower int,upper int) bool
    dfs = func(node *TreeNode,lower int,upper int) bool {
        if node == nil {return true}

        if node.Val <= lower || node.Val >= upper {
            return false
        }
        return dfs(node.Left,lower,node.Val) && dfs(node.Right,node.Val,upper)
    }
    return dfs(root,math.MinInt64,math.MaxInt64)
}
```

> 复杂度分析
时间复杂度：$O(n)$，其中 n 为二叉树的节点个数。在递归调用的时候二叉树的每个节点最多被访问一次，因此时间复杂度为 $O(n)$。
空间复杂度：$O(n)$，其中 n 为二叉树的节点个数。递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，即二叉树的高度。最坏情况下二叉树为一条链，树的高度为 n ，递归最深达到 n 层，故最坏情况下空间复杂度为 $O(n)$ 。
> 

## **A.44.30. 二叉搜索树中第 K 小的元素**

中序遍历，找出第k个元素，

```go
func kthSmallest(root *TreeNode, k int) int {
    arr := []int{}
    var dfs func(node *TreeNode)
    dfs = func(node *TreeNode){
        if node == nil{return}
        dfs(node.Left)
        arr = append(arr,node.Val)
        dfs(node.Right)
    }
    dfs(root)
    return arr[k-1]
}
```

> 复杂度分析
时间复杂度：预处理的时间复杂度为 O(N)
空间复杂度：O(N)
> 

## **B.45.199. 二叉树的右视图**

很常见的，层序遍历，只是取最后一个数字

```go
func rightSideView(root *TreeNode) []int {
    arr := [][]int{}
    depth := 0
    var order func(node *TreeNode,depth int)
    order = func(node *TreeNode,depth int){
        if node == nil{return}
        if len(arr)== depth {arr = append(arr,[]int{})}
        arr[depth] = append(arr[depth] ,node.Val)
        order(node.Left,depth+1)
        order(node.Right,depth+1)
    }
    order(root,depth)
    ans :=[]int{}
    for _,level:=range arr{
        ans=append(ans,level[len(level)-1])
    }
    return ans
}
```

> 复杂度分析
时间复杂度：O(n)，其中 n 是二叉树的节点个数。
空间复杂度：O(n)，其中 n 是二叉树的节点个数。
> 

## **B.46.114. 二叉树展开为链表**

逆先序遍历，然后把后面的插到前面，

```go
func flatten(root *TreeNode)  {
    var tail *TreeNode
    var dfs func(node *TreeNode)
    dfs = func(node *TreeNode){
        if node == nil {return}
        // arr = append(arr,node)
        dfs(node.Right)
        dfs(node.Left)
        node.Left=nil
        node.Right=tail
        tail = node
    }
    dfs(root)
}
```

> 复杂度分析
时间复杂度：O(n)，其中 n 是二叉树的节点个数。
空间复杂度：O(n)。递归需要 O(n) 的栈空间。
> 

## **C.47.105. 从前序与中序遍历序列构造二叉树**

还是使用 leetcode 官方题解，获取i的位置，左右长度 放入

递归是神，记得左闭右开，一个map 存储 pre 在 in 中的位置，

```go
func buildTree(preorder []int, inorder []int) *TreeNode {
    n := len(preorder)
    m := make(map[int]int,n)//记录先序中的元素，在中序中的位置
    for i,v := range inorder{
        m[v] = i
    }

    var dfs func(preL,preR,inL,inR int)*TreeNode
    dfs = func(preL,preR,inL,inR int)*TreeNode{
        if preL == preR{return nil}
        Lsize := m[preorder[preL]] - inL //左子树大小
        left := dfs(preL+1,preL+1+Lsize,inL,inL+Lsize) //区间都是左闭右开
        right := dfs(preL+1+Lsize,preR,inL+1+Lsize,inR)//但是因为inorder中间有root节点
        return &TreeNode{preorder[preL],left,right}

    }
    return dfs(0,n,0,n)
}
```

> 复杂度分析
时间复杂度：O(n)，其中 n 为 preorder 的长度。递归 O(n) 次，每次只需要 O(1) 的时间。
空间复杂度：O(n)。
> 

## **C.48.437. 路径总和 III**

灵魂一步 

```go
// 判断是否存在从某一节点到当前节点的路径和等于 targetSum
// 如果存在，路径数量增加 cnt[s - targetSum]
ans += cnt[s-targetSum]
```

结合前缀和，递归，回溯

```go
func pathSum(root *TreeNode, targetSum int) int {
    cnt := map[int]int{0:1}
    ans :=0
    var dfs func(node *TreeNode,s int)
    dfs = func(node *TreeNode,s int){
        if node == nil{return}
        s+=node.Val
        ans += cnt[s-targetSum]
        cnt[s]++
        dfs(node.Left,s)
        dfs(node.Right,s)
        cnt[s]--
    }
    dfs(root,0)
    return ans
}
```

> 复杂度分析
时间复杂度：O(n)，其中 n 是二叉树的节点个数。
空间复杂度：O(n)。
> 

### **560. 和为 K 的子数组**

前缀和代码片段

```go
func subarraySum(nums []int, k int) int {
    cnt := map[int]int{0:1}
    ans,s:=0,0
    for _,v:=range nums{
        s+=v
        ans += cnt[s-k]
        cnt[s]++
    }
    return ans 
}
```

## **B.49.236. 二叉树的最近公共祖先**

我写的有点丑陋

很优雅的代码，上浮节点，遇到p，或者q，或者nil，就上浮，尽可能返回非nil 的节点

```go
 func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    if root == nil || root == p || root == q{return root}
    left := lowestCommonAncestor(root.Left,p,q)
    right := lowestCommonAncestor(root.Right,p,q)
    if left == nil{return right}
    if right == nil{return left}
    return root
}
```

> 复杂度分析
时间复杂度：O(n)，其中 n 为二叉树的节点个数。
空间复杂度：O(n)。最坏情况下，二叉树是一条链，因此递归需要 O(n) 的栈空间。
> 

## **C.50.124. 二叉树中的最大路径和**

和二叉树的半径差不多，不需要什么前缀和，max 函数 可以接收 多个 参数

没有想象的那么难，还是这样的，还有go 的闭包，和python 闭包不一样，可以修改外部变量值

```go
func maxPathSum(root *TreeNode) int {
    ans := math.MinInt
    var dfs func(node *TreeNode)int
    dfs = func(node *TreeNode)int {
        if node == nil{return 0}
        L,R := dfs(node.Left),dfs(node.Right)
        ans = max(ans,L+R+node.Val)
        return max(max(L,R)+node.Val,0)
    }
    dfs(root)
    return ans
}
```

> 复杂度分析
时间复杂度：O(n)，其中 n 为二叉树的节点个数。
空间复杂度：O(n)。最坏情况下，二叉树退化成一条链，递归需要 O(n) 的栈空间。
> 

## **C.51.200. 岛屿数量**

好好使用递归方法，dfs 是个很好的实现，还有每个 节点存放的 是 ‘1’ 不是 “1”，

遍历mxn矩阵，如果是1使用dfs 全部染色(改成1以外的数字)，然后ans 加1

```go
func numIslands(grid [][]byte) int {

    ans,m,n := 0,len(grid),len(grid[0])
    var dfs func(i int,j int)
    dfs = func(i int,j int){
        if i<0 || i>= m || j<0 || j>= n || grid[i][j]!= '1'{
            return
        }
        grid[i][j] = '2'
        dfs(i,j-1)
        dfs(i,j+1)
        dfs(i-1,j)
        dfs(i+1,j)
    }

    for i,row := range grid{
        for j,col := range row{
            if col== '1'{
                dfs(i,j)
                ans++
            }
        }
    }
    return ans
}
```

> 复杂度分析
时间复杂度：O(mn)，其中 m 和 n 分别为 grid 的行数和列数。
空间复杂度：O(mn)。最坏情况下，递归需要 O(mn) 的栈空间。
> 

## **C.52.994. 腐烂的橘子**

多源头bfs，先统计第一轮新鲜橘子个数，和此轮腐烂橘子的位置，bfs，下一轮

```go
type pair struct{
    row int
    col int
}
var dir = []pair{{-1,0},{1,0},{0,-1},{0,1}} //定义四个方向

func orangesRotting(grid [][]int) int {
    m,n := len(grid),len(grid[0])
    fresh := 0
    q:= []pair{}
    for i,row := range grid{//统计初始状态新鲜橘子个数，和腐烂橘子的位置
        for j,x := range row{
            if x == 1{
                fresh++
            }else if x==2{
                q = append(q,pair{i,j})
            }
        }
    }

    ans := 0
    for fresh >0 && len(q)>0 {// q存储新一轮腐烂的橘子，然后四个方向遍历，更新q
        ans++
        tmp := q
        q = []pair{}
        for _,p:= range tmp{
            for _,d := range dir{
                i,j := p.row+d.row,p.col+d.col
                if 0<= i && i <m && 0<= j && j <n && grid[i][j] == 1 {
                    fresh--
                    grid[i][j] = 2
                    q = append(q,pair{i,j})
                }
            }
        }
    }
    if fresh > 0 {
        return -1
    }
    return ans
}
```

> 复杂度分析
时间复杂度：O(mn)，其中 m 和 n 分别为 grid 的行数和列数。
空间复杂度：O(mn)。
> 

## **C.53.207. 课程表**

就是判断一个有向图是否有环，染色标记，正在访问，dfs

```go
func canFinish(numCourses int, prerequisites [][]int) bool {
    g := make([][]int,numCourses) //构建邻接表
    for _,p:= range prerequisites{
        g[p[1]]=append(g[p[1]],p[0])
    }
    

    colors := make([]int,numCourses)
    var dfs func(x int) bool //检测是否有环路，
    dfs = func(x int) bool{
        colors[x]=1
        for _,y:= range g[x]{
            if colors[y] == 1 || colors[y] ==0 && dfs(y){ // 如果遇到正在访问的
                return true//，有环或者新的连接到环路了，
            }
        }
        colors[x] = 2
        return false
    }

    for i,c := range colors{
        if c ==0 && dfs(i){ // 访问节点，有环就返回false
            return false
        }
    }
    return true

}
```

> 复杂度分析
时间复杂度：O(n+m)，其中 n 是 numCourses，m 是 prerequisites 的长度。每个节点至多递归访问一次，每条边至多遍历一次。
空间复杂度：O(n+m)。存储 g 需要 O(n+m) 的空间。
> 

## C.54.**208. 实现 Trie (前缀树)**

新添加一个find 函数 返回 int 类型，

```go
type Trie struct {
    son [26]*Trie
    end bool
}

func Constructor() Trie {
    return Trie{}
}

func (this *Trie) Insert(word string)  {
    cur := this
    for _,c := range word{
        c -= 'a'
        if cur.son[c] == nil{
            cur.son[c] = &Trie{}
        }
        cur = cur.son[c]
    }
    cur.end = true
}

func (this *Trie) find(word string) int {
    cur := this
    for _,c := range word{
        c -= 'a'
        if cur.son[c] == nil{
            return 0
        }
        cur = cur.son[c]
    }
    if cur.end{
        return 2
    }
    return 1
}

func (this *Trie) Search(word string) bool {
    return this.find(word) == 2
}

func (this *Trie) StartsWith(prefix string) bool {
    return this.find(prefix) !=0
}
```

> 复杂度分析
时间复杂度：初始化为 O(1)，其余操作为 O(∣S∣)，其中 ∣S∣ 是每次插入或查询的字符串的长度。
空间复杂度：O(∣T∣⋅Σ)，其中 ∣T∣ 为所有插入字符串的长度之和，Σ 为字符集的大小，本题 Σ=26。
> 

## **B.55.46. 全排列**

回溯，和python 不一样的地方在于go 闭包可以改变外部函数，直接定义全局变量

```go
var (
    res  [][]int
    path []int
    st []bool
)
func permute(nums []int) [][]int {
    res,path,st= make([][]int,0),make([]int,0,len(nums)),make([]bool,len(nums))
    dfs(nums,0)
    return res
}

func dfs(nums []int,depth int){
    if depth == len(nums){
        tmp:=make([]int,len(nums))
        copy(tmp,path)
        res  = append(res,tmp)
    }
    for i:=0;i<len(nums);i++{
        if st[i]!=true{
            path = append(path,nums[i])
            st[i] = true
            dfs(nums,depth+1)
            st[i] = false
            path = path[:len(path)-1]
        }

    }
}
```

> 复杂度分析
时间复杂度：O(n⋅n!)，其中 n 为 nums 的长度。视频中提到，搜索树中的节点个数低于 3⋅n!。实际上，精确值为 ⌊e⋅n!⌋，其中 e=2.718⋯ 为自然常数。每个非叶节点要花费 O(n) 的时间遍历 onPath 数组，每个叶结点也要花费 O(n) 的时间复制 path 数组，因此时间复杂度为 O(n⋅n!)。
空间复杂度：O(n)。返回值的空间不计入。
> 

## C.56.**78. 子集**

组合问题，要传入start，任意长度都可以，

```go
var (
    res [][]int
    path []int
    st []bool
)

func subsets(nums []int) [][]int {
    res,path,st=make([][]int,0) ,make([]int,0,len(nums)),make([]bool,len(nums))
    dfs(nums,0)
    return res
}

func dfs(nums []int,start int){
    tmp := make([]int,len(path))
    copy(tmp,path)
    res = append(res,tmp)
    if len(path) ==len(nums){
        return
    }
    for i:=start;i<len(nums);i++{
        if st[i]!= true{
            st[i]=true
            path = append(path,nums[i])
            dfs(nums,i)
            path = path[:len(path)-1]
            st[i]=false
        }

    }

}
```

> 复杂度分析
时间复杂度：$O(n×2^n)$。一共 $2^n$个状态，每种状态需要 $O(n)$ 的时间来构造子集。
空间复杂度：$O(n)$。即构造子集使用的临时数组 t 的空间代价。
> 

## **B.57.17. 电话号码的字母组合**

如果字符串为空的话，直接返回空[]string

```go
var (
    m []string
    path []byte
    res []string
)
func letterCombinations(digits string) []string {
    m = []string{"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"}
    path, res = make([]byte, 0), make([]string, 0)
    if digits == "" {
        return res
    }
    dfs(digits, 0)
    return res
}
func dfs(digits string, start int) {
    if len(path) == len(digits) {  //终止条件，字符串长度等于digits的长度
        tmp := string(path)
        res = append(res, tmp)
        return
    }
    digit := int(digits[start] - '0')  // 将index指向的数字转为int（确定下一个数字）
    str := m[digit-2]   // 取数字对应的字符集（注意和map中的对应）
    for j := 0; j < len(str); j++ {
        path = append(path, str[j])
        dfs(digits, start+1)
        path = path[:len(path)-1]
    }
}
```

> **复杂度分析**
**时间复杂度**：$O(3^m×4^n)$，其中 m 是输入中对应 3 个字母的数字个数（包括数字 2、3、4、5、6、8），n 是输入中对应 4 个字母的数字个数（包括数字 7、9），m+n 是输入数字的总个数。当输入包含 m 个对应 3 个字母的数字和 n 个对应 4 个字母的数字时，不同的字母组合一共有 $3^m×4^n$种，需要遍历每一种字母组合。
**空间复杂度**：$O(m+n)$，其中 m 是输入中对应 3 个字母的数字个数，n 是输入中对应 4 个字母的数字个数，m+n 是输入数字的总个数。除了返回值以外，空间复杂度主要取决于哈希表以及回溯过程中的递归调用层数，哈希表的大小与输入无关，可以看成常数，递归调用层数最大为 m+n。
> 

## **B.58.39. 组合总和**

start 和 i 来确保不会重复选取

```go
var (
    res [][]int
    path []int
    sum int
)
func combinationSum(candidates []int, target int) [][]int {
    res, path,sum = make([][]int,0),make([]int,0),0
    dfs(candidates,0,target)
    return res
}

func dfs(candidates []int,start int, target int){
    if sum >= target{
        if sum == target{
            tmp:=make([]int,len(path))
            copy(tmp,path)
            res = append(res,tmp)
        }
        return
    }
    for i:=start;i<len(candidates);i++{
        sum += candidates[i]
        path = append(path,candidates[i])
        dfs(candidates,i,target)
        path = path[:len(path)-1]
        sum -= candidates[i]
    }
}
```

> **复杂度分析**
**时间复杂度**：O(S)，其中 S 为所有可行解的长度之和。从分析给出的搜索树我们可以看出时间复杂度取决于搜索树所有叶子节点的深度之和，即所有可行解的长度之和。在这题中，我们很难给出一个比较紧的上界，我们知道 $O(n×2^n)$ 是一个比较松的上界，即在这份代码中，n 个位置每次考虑选或者不选，如果符合条件，就加入答案的时间代价。但是实际运行的时候，因为不可能所有的解都满足条件，递归的时候我们还会用 target−candidates[idx]≥0 进行剪枝，所以实际运行情况是远远小于这个上界的。
**空间复杂度**：O(target)。除答案数组外，空间复杂度取决于递归的栈深度，在最差情况下需要递归 O(target) 层
> 

## **B.59.22. 括号生成**

就是左右2个元素的 回溯，使用 left<n 和 i-left<left 来实现

```go
func generateParenthesis(n int) []string {
    /*
    这一题关键 
    (  = left
    ) = depth - left
    */
    ans:=[]string{}
    path:=[]rune{}
    left:=0

    var dfs func(depth int)
    dfs = func(depth int){
        // 终止条件

        if depth==n*2{
            ans=append(ans,string(path))
            return
        }
        if left <n { // 可以加入左括号
            path=append(path,'(')
            left++
            dfs(depth+1)
            left--
            path=path[:len(path)-1]
        }
        if depth - left < left { //可以加入右边括号
            path=append(path,')')
            dfs(depth+1)
            path=path[:len(path)-1]

        }
    }

    dfs(0)
    return ans

}
```

> 
> 
> 
> ### 复杂度分析
> 
> ### 时间复杂度
> 
> 分析回溯问题的时间复杂度有一个通用公式：
> 
> **路径长度 × 搜索树的叶子数**。
> 
> 对于本题，其等于 $O(n \cdot C(2n, n))$。
> 
> 但由于左右括号的约束，实际上没有这么多叶子节点。根据 Catalan 数，只有 $C(2n, n) / (n + 1)$ 个叶子节点，所以实际的时间复杂度为：
> 
> $O(C(2n, n))$
> 
> 此外，根据阶乘的 Stirling 公式，时间复杂度也可以表示为：
> 
> $O\left(\frac{4^n}{\sqrt{n}}\right)$
> 
> ### 空间复杂度
> 
> 空间复杂度为 $O(n)$。返回值的空间不计入。
> 

## **B.60.79. 单词搜索**

上下左右的模板要记一下

```go
/*
错误情况 
边界情况
0 < c && 0 < r  改为
0 <= c  && 0 <= r 
*/

var dirs = []struct{x,y int}{{0,-1},{0,1},{-1,0},{1,0}}
func exist(board [][]byte, word string) bool {
    m,n := len(board),len(board[0])
    var dfs func(int,int,int) bool
    dfs = func(i,j,k int) bool{
        if board[i][j] != word[k]{
            return false
        }
        if k == len(word)-1 {
            return true
        }
        board[i][j]=0
        for _,d := range dirs{
            x,y := i+d.x,j+d.y
            if 0<= x && x<m && 0<=y && y<n && dfs(x,y,k+1){
                return true
            }
        }
        board[i][j] = word[k]//回溯
        return false
    }
    for i :=0 ;i<m;i++{
        for j :=0;j<n;j++{
            if dfs(i,j,0){
                return true
            }
        }
    }
    return false
}
```

> 复杂度分析
时间复杂度：$O(mn3^k)$，其中 m 和 n 分别为 grid 的行数和列数，k 是 word 的长度。除了递归入口，其余递归至多有3个分支（因为至少有一个方向是之前走过的），所以每次递归（回溯）的时间复杂度为 $O(3^k)$，一共回溯 $O(mn)$ 次，所以时间复杂度为 $O(mn3^k)$。
空间复杂度：$O(∣Σ∣+k)$。其中 ∣Σ∣=52 是字符集合的大小。递归需要 $O(k)$ 的栈空间。部分语言用的数组代替哈希表，可以视作 ∣Σ∣=128。
> 

## **B.61.131. 分割回文串**

就是暴力遍历，分割检测，每个字母都有2中状态，check 和 不check

一个检测是否是回文的函数，is_p, 把字符串切片放入path中间

```go
var (
    path []string  // 放已经回文的子串
    res  [][]string
)
func partition(s string) [][]string {
    path, res = make([]string, 0), make([][]string, 0)
    dfs(s, 0)
    return res
}

func dfs(s string, start int) {
    if start == len(s) { // 如果起始位置等于s的大小，说明已经找到了一组分割方案了
        tmp := make([]string, len(path))
        copy(tmp, path)
        res = append(res, tmp)
        return 
    }
    for i := start; i < len(s); i++ {
        str := s[start : i+1]
        if isPalindrome(str) {   // 是回文子串
            path = append(path, str)
            dfs(s, i+1)         // 寻找i+1为起始位置的子串
            path = path[:len(path)-1]  // 回溯过程，弹出本次已经添加的子串
        }
    }
}

func isPalindrome(s string) bool {
    for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
        if s[i] != s[j] {
            return false
        }
    }
    return true
}
```

> 复杂度分析
时间复杂度: $O(n * 2^n)$
空间复杂度: $O(n)$
> 

## C.62.**51. N 皇后**

主要是 isValid 函数,检查正上方，左上方，右上方，是否有Q，

```go
var (
    ans [][]string
    path [][]rune
)

func solveNQueens(n int) [][]string {
    ans,path=make([][]string,0),make([][]rune,n)
    for i:=0;i<n;i++{
        path[i]=make([]rune,n)
        for j:=0;j<n;j++{
            path[i][j]='.'
        }
    }
    dfs(0,n)
    return ans
}

func dfs(depth,n int){
    if depth == n{
        tmp:=make([]string,n)
        for i,row_str := range path{
            tmp[i]=string(row_str)
        }
        ans=append(ans,tmp)
        return
    }
    for j:=0;j<n;j++{
        if is_valid(depth,j,n){
            path[depth][j]='Q'
            dfs(depth+1,n)
            path[depth][j]='.'
        }
        
    }

}

func is_valid(row int,col int,n int)bool{
    for i:=0;i<n;i++{  //正上方
        if path[i][col]=='Q'{
            return false
        }
    }
    for i,j:=row-1,col-1;i>=0&&j>=0;i,j=i-1,j-1{ //左上方
        if path[i][j]=='Q'{
            return false
        }
    }
    for i,j:=row-1,col+1;i>=0&&j<n;i,j=i-1,j+1{ //右上方
        if path[i][j]=='Q'{
            return false
        }
    }
    return true
}
```

> 复杂度分析
时间复杂度: O(n!)
空间复杂度: O(n)
> 

## B.63.**35. 搜索插入位置**

二分查找，模板常用

```go
func searchInsert(nums []int, target int) int {
    left,right :=0,len(nums)-1
    for left <= right {
        mid := (right+left)/2
        if nums[mid] == target{
            return mid
        }else if nums[mid]<target{
            left=mid +1
        } else {
            right = mid-1
        }
    }
    return left
}
```

> 复杂度分析
时间复杂度：$O(logn)$，其中 n 为数组的长度。二分查找所需的时间复杂度为 $O(logn)$。
空间复杂度：$O(1)$。我们只需要常数空间存放若干变量。
> 

## **64.74. 搜索二维矩阵**

二分两次，另一个重点 找第一个大于的，第一个严格大于的，代码不要改动，可以后面加偏移量，

```go
func searchMatrix(matrix [][]int, target int) bool {

    up,down:=0,len(matrix)-1
    for up<=down{
        mid:=(up+down)/2
        if matrix[mid][0]==target{
            return true
        }else if matrix[mid][0]<target{
            up = mid + 1
        }else{
            down = mid - 1
        }
    }
    up--
    
    if up < 0{return false}
    left,right := 0,len(matrix[0])-1
    for left<=right{
        mid:=(left+right)/2
        if matrix[up][mid]==target{
            return true
        }else if matrix[up][mid]<target{
            left = mid + 1
        }else{
            right = mid -1
        }
    }
    return false
}

```

> 复杂度分析
时间复杂度：O(logm+logn)=O(logmn)，其中 m 和 n 分别是矩阵的行数和列数。
空间复杂度：O(1)。
> 

## **C.65.34. 在排序数组中查找元素的第一个和最后一个位置**

左右下标真的难受，终于整理出来模板了，

```go
func searchRange(nums []int, target int) []int {
    lmid,rmid:=-1,-1
    left,right:= 0 ,len(nums)-1
    for left <= right{
        mid:=(left+right)/2
        if nums[mid] == target{
            right = mid -1
            lmid = mid
        }else if nums[mid] < target{
            left = mid + 1
        }else{
            right = mid -1
        }
    }
    left,right = 0 ,len(nums)-1
    for left <= right{
        mid:=(left+right)/2
        if nums[mid] == target{
            left = mid +1
            rmid = mid
        }else if nums[mid] < target{
            left = mid + 1
        }else{
            right = mid -1
        }
    }
    if lmid>=0 && nums[lmid]==target && nums[rmid] == target {
        return []int{lmid,rmid}
    }else{
        return []int{-1,-1}
    }
}
```

> 复杂度分析
时间复杂度： $O(logn)$ ，其中 n 为数组的长度。二分查找的时间复杂度为 $O(logn)$，一共会执行两次，因此总时间复杂度为 $O(logn)$。
空间复杂度：$O(1)$ 。只需要常数空间存放若干变量。
> 

## C.66.**33. 搜索旋转排序数组**

找到最小值坐标，作为偏移量，然后作为偏移量访问，假设长度为2倍，对n取模

```go
func search(nums []int, target int) int {
    left,right:=0,len(nums)-1
    for left<=right{
        mid:= (left+right)/2
        if nums[mid] == nums[right]{
            break
        }else if  nums[mid] > nums[right]{
            left  = mid +1
        }else{
            right = mid
        }
    }

    // tmp:=left
    left,right=0+left,len(nums)-1+left
    for left<=right{
        mid:=(left+right)/2
        if nums[mid%len(nums)]== target{
            return mid%len(nums)
        }else if nums[mid%len(nums)]<target{
            left = mid+1
        }else{
            right = mid -1
        }
    }
    return -1
}
```

> 复杂度分析
时间复杂度： $O(logn)$ ，其中 n 为数组的长度。
空间复杂度：$O(n)$ 。只需要常数空间存放若干变量。
> 

## 67.**153. 寻找旋转排序数组中的最小值**

使用 统一模板，记得转换的条件一直是 nums[mid] < nums[right] 和 nums[mid] > nums[right]

```go
func findMin(nums []int) int {
    left,right:=0,len(nums)-1
    for left <= right{ // 这里一般是要 <= 的，
        mid:=(left+right)/2
        if nums[mid] == nums[right] {
            break
        }else if nums[mid] < nums[right]{
            right = mid // 因为 mid 可能已经命中结果 所以不做 mid-1
        }else{
            left = mid + 1 // 因为 mid 一定没有命中结果 所以 mid +1 
        }
    }
    return nums[left]
}
```

> 复杂度分析
时间复杂度：时间复杂度为 $O(logn)$，其中 n 是数组 nums 的长度。在二分查找的过程中，每一步会忽略一半的区间，因此时间复杂度为 $O(logn)$。
空间复杂度：$O(1)$。
> 

## ***68.4. 寻找两个正序数组的中位数**

这题分割线，然后左右移动下边的判断条件，使用开区间，为了省去处理 math.MinInt

```go
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    if len(nums1) > len(nums2) {
        nums1, nums2 = nums2, nums1
    }
    m,n:=len(nums1),len(nums2)
    // 循环不变量 a[left]<=b[j+1]
    // 循环不变量 a[right]>b[j+1]
    left,right:= -1,m  
    for left+1<right { //开区间 (left,right) 不为空
        i:=(left+right)/2
        j:=(m+n+1)/2 -2 -i
        if nums1[i]<=nums2[j+1]{
            left = i // 缩小二分区间为 (i, right)
        }else{
            right = i // 缩小二分区间为 (left, i)
        }
    }

    //此时 left == right -1
    // a[left] <= b[j+1] 且 a[right] > b[j+1] = b[j],所以答案是 i=left
    i:=left
    j := (m+n+1)/2 - 2 - i
    ai:=math.MinInt;if i>=0 {ai=nums1[i]}
    bj:=math.MinInt;if j>=0 {bj=nums2[j]}
    ai1:= math.MaxInt;if i+1<m {ai1=nums1[i+1]}
    bj1:= math.MaxInt;if j+1<n {bj1=nums2[j+1]}

    max1:=max(ai,bj) //左边边部分最右端
    min2:=min(ai1,bj1) //右边部分最左端
    if (m+n)%2 >0 {
        return float64(max1)
    }
    return float64(max1+min2)/2

}
```

> 复杂度分析
时间复杂度：$O(logmin(m,n))$，其中 m 是 a 的长度，n 是 b 的长度。注：这个复杂度比题目所要求的 $O(log(m+n))$ 更优。
空间复杂度：$O(1)$。
> 

## 69.**20. 有效的括号**

简单的栈的使用

```go
func isValid(s string) bool {
    st := []rune{}
    m := map[rune]rune{')':'(',']':'[','}':'{'}
    for _,v:=range s{
        if len(st)!=0 && m[v]== st[len(st)-1]{
            st = st[:len(st)-1]
        }else{
            st = append(st,v)
        }
    }
    return len(st)==0
}
```

> 复杂度分析
时间复杂度：O(n)，其中 n 是 s 的长度。
空间复杂度：O(n) 。
> 

## **70.155. 最小栈**

两个栈，一个栈就放普通元素，另一个放最小值，最底层放一个 math.MaxInt

```go
type MinStack struct {
    st []int
    minst []int
}

func Constructor() MinStack {
    return MinStack{
        st: []int{},
        minst: []int{math.MaxInt64},
    }
}

func (this *MinStack) Push(val int)  {
    this.st = append(this.st,val)
    top := this.minst[len(this.minst)-1]
    this.minst = append(this.minst,min(val,top))
}

func (this *MinStack) Pop() {
    this.st = this.st[:len(this.st)-1]
    this.minst = this.minst[:len(this.minst)-1]
}

func (this *MinStack) Top() int {
    return this.st[len(this.st)-1]
}

func (this *MinStack) GetMin() int {
    return this.minst[len(this.minst)-1]
}

```

> 复杂度分析
时间复杂度：对于题目中的所有操作，时间复杂度均为 O(1)。因为栈的插入、删除与读取操作都是 O(1)，我们定义的每个操作最多调用栈操作两次。
空间复杂度：O(n)，其中 n 为总操作数。最坏情况下，我们会连续插入 n 个元素，此时两个栈占用的空间为 O(n)。
> 

## **71.394. 字符串解码**

两个栈，一个存数字，一个栈存 临时字符串片段，用 num 计算 数值，res 每个**片段都会入栈**

```go

func decodeString(s string) string {
    num_st := []int{}
    str_st := []string{}
    num := 0 
    res := "" //储存临时字符串 但最终会成为结果
    for _,char := range s{
        if '0' <= char && char <= '9' { //如果是数字处理数字
            n  := char - '0'
            num = num*10 + int(n)
        }else if char == '[' { // '[' 将临时字符串和数字放入其中
            str_st = append(str_st,res)
            res = ""
            num_st = append(num_st,num)
            num = 0
        }else if char == ']'{ // 如果是 ']' 将字符串 和 数字从栈中拿出 组合
            count := num_st[len(num_st)-1]
            num_st = num_st[:len(num_st)-1]
            str := str_st[len(str_st)-1]
            str_st = str_st[:len(str_st)-1]
            res = string(str) + strings.Repeat(res, count)
        }else{ // 字符串叠加到 res 中临时保存
            res += string(char)
        }
    }
    return res
}

```

> **复杂度分析**
**时间复杂度**：记解码后得出的字符串长度为 S，除了遍历一次原字符串 s，我们还需要将解码后的字符串中的每个字符都拼接进答案中，故渐进时间复杂度为 O(S+∣s∣)，即 O(S)。
**空间复杂度**：若不考虑答案所占用的空间，那么就只剩递归使用栈空间的大小，这里栈空间的使用和递归树的深度成正比，最坏情况下为 O(∣s∣)，故渐进空间复杂度为 O(∣s∣)。
> 

## 72.**739. 每日温度**

单调栈，记得要入栈，出栈， 出栈要出所有影响单调的元素

```go

func dailyTemperatures(temperatures []int) []int {
    length := len(temperatures)
    ans := make([]int,length)
    stack := []int{}
    for i,_ := range temperatures{
        t := temperatures[i]
        for len(stack)!=0 && t > temperatures[stack[len(stack)-1]]{ // 连续弹出所有 小于的
            prvIndex := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            ans[prvIndex] =  i-prvIndex //记录 弹出元素 的下标 和目前的下标差值
        }
        stack = append(stack,i)
    }
    return ans
}

```

> 
> 

## ***73.84. 柱状图中最大的矩形**

单调栈，记得append，最大值一定是 hight * (左右左边第一个比自己小的下标的差)

```go
func largestRectangleArea(heights []int) int {
    n:=len(heights)
    left:= make([]int,n)
    stack := []int{}
    ans :=0
    for i,x := range heights{// 找出所有左边第一个 比自己小的 
        for len(stack) >0 && x<= heights[stack[len(stack)-1]]{
            stack = stack[:len(stack)-1]
        }
        if len(stack)>0{
            left[i] = stack[len(stack)-1]
        }else{
            left[i] = -1
        }
        stack = append(stack,i)
    }
    right := make([]int,n)
    stack = stack[:0]
    for i:= n-1;0<=i;i--{ //找出右边所有第一个比自己小的
        for len(stack)>0 && heights[i] <= heights[stack[len(stack)-1]]{
            stack = stack[:len(stack)-1]
        }
        if len(stack)>0 {
            right[i] = stack[len(stack)-1]
        }else{
            right[i] = n
        }
        stack = append(stack,i)
    }

    for i,v:=range heights{
        ans = max(ans,v*(right[i]-left[i]-1))
    }
    return ans
}
```

> 复杂度分析
时间复杂度：O(n)，其中 n 为 heights 的长度。
空间复杂度：O(n)。
> 

## ***74.215. 数组中的第K个最大元素**

使用更改过的快排，让基准值，最终位置尽可能靠近n-k

```go
func findKthLargest(nums []int, k int) int {
    n:= len(nums)
    return quickselect(nums,0,n-1,n-k)
}

func quickselect(nums []int,l,r,k int) int {
    if (l==r){
        return nums[k]
    }
    partition:=nums[l]
    i,j:= l-1,r+1
    for i<j{
        for i++;nums[i]<partition;i++{}
        for j--;nums[j]>partition;j--{}
        if i<j {
            nums[i],nums[j]= nums[j],nums[i]
        }
    }
    if k<=j {
        return quickselect(nums,l,j,k)
    }else{
        return quickselect(nums,j+1,r,k)
    }
}

```

堆排序

```go
package main

import "fmt"

// 堆排序主函数
func heapSort(arr []int) {
	n := len(arr)

	// 构建最大堆
	for i := n/2 - 1; i >= 0; i-- {
		heapify(arr, n, i)
	}

	// 逐步将堆顶元素移到数组末尾，并调整堆
	for i := n - 1; i > 0; i-- {
		// 将堆顶（最大值）与当前末尾元素交换
		arr[0], arr[i] = arr[i], arr[0]

		// 调整堆，排除已排序的元素
		heapify(arr, i, 0)
	}
}

// 堆调整函数，将以 index 为根的子树调整为最大堆
func heapify(arr []int, n int, index int) {
	largest := index    // 假设当前节点是最大值
	left := 2*index + 1 // 左子节点
	right := 2*index + 2 // 右子节点

	// 如果左子节点存在且比根节点大，更新最大值
	if left < n && arr[left] > arr[largest] {
		largest = left
	}

	// 如果右子节点存在且比当前最大值大，更新最大值
	if right < n && arr[right] > arr[largest] {
		largest = right
	}

	// 如果最大值不是根节点，交换并递归调整子树
	if largest != index {
		arr[index], arr[largest] = arr[largest], arr[index]
		heapify(arr, n, largest)
	}
}

// 测试代码
func main() {
	arr := []int{3, 6, 8, 10, 1, 2, 1}
	fmt.Println("原始数组:", arr)

	heapSort(arr)

	fmt.Println("堆排序后的数组:", arr)
}

```

## **75.347. 前 K 个高频元素**

实现堆，先记录记录频次，然后push入小顶堆，容量大于k时pop，最后用一个数组全部接收剩下的

```go
func topKFrequent(nums []int, k int) []int {
    count := map[int]int{}
    for _,v:= range nums{
        count[v]++
    }
    h := &MyHeap{}
    heap.Init(h) //堆化
    for key,v:= range count{ //在保证堆的容量不超过k的前提下，不断push元素
        heap.Push(h,[2]int{key,v})
        if h.Len()>k{
            heap.Pop(h)
        }

    }
    res := make([]int,k)
    for i:=0;i<k;i++{
        res[k-1-i] = heap.Pop(h).([2]int)[0]
    }
    return res
}

type MyHeap [][2]int

func (hp MyHeap)Len()int{return len(hp)}
func (hp MyHeap)Less(i int,j int)bool{return hp[i][1]<hp[j][1]}
func (hp MyHeap)Swap(i int,j int){hp[i],hp[j]=hp[j],hp[i]}
func (hp *MyHeap)Push(x any){*hp = append(*hp,x.([2]int))}
func (hp *MyHeap)Pop()any{
    old := *hp
    n := len(old)
    x := old[n-1]
    *hp = old[:n-1]
    return x
}
```

> 复杂度分析
时间复杂度：O(Nlogk)，其中 N 为数组的长度。我们首先遍历原数组，并使用哈希表记录出现次数，每个元素需要 O(1) 的时间，共需 O(N) 的时间。随后，我们遍历「出现次数数组」，由于堆的大小至多为 k，因此每次堆操作需要 O(logk) 的时间，共需 O(Nlogk) 的时间。二者之和为 O(Nlogk)。
空间复杂度：O(N)。哈希表的大小为 O(N)，而堆的大小为 O(k)，共计为 O(N)。
> 

## **76.295. 数据流的中位数**

两个小顶堆，一个left 元素取负数，实现大顶堆， left 存放较小元素[0]最大，right 存放较大元素[0]最小,可以允许left 比right 多一个，

1 存入方式，两个大小一样，先push 入右边，然后 pop 到左边，不一样则反过来，保证存入的元素在左右都比较过大小，

2 找中间值方式，相等，取left[0]+right[0]的均值，否则取 left[0]

3 (*this.right)[0] 先解引用，然后再 索引

### 引用优先级

```
具体的优先级可以总结为：

[] 优先级最高
* 优先级高于 .
. 最低
```

```go
type MedianFinder struct {
    left *MyHeap
    right *MyHeap    
}

func Constructor() MedianFinder {
    hp1 := &MyHeap{}
    heap.Init(hp1)
    hp2 := &MyHeap{}
    heap.Init(hp2)
    return MedianFinder{left:hp1,right:hp2}
}

func (this *MedianFinder) AddNum(num int)  {
    if this.left.Len() == this.right.Len(){
        heap.Push(this.right,num)
        heap.Push(this.left,-heap.Pop(this.right).(int))
    }else{
        heap.Push(this.left,-num)
        heap.Push(this.right,-heap.Pop(this.left).(int))
    }
}

func (this *MedianFinder) FindMedian() float64 {
    if this.left.Len() == this.right.Len(){
        return float64((*this.right)[0]-(*this.left)[0])/2.0
    }
    return float64(-(*this.left)[0]) 
}

type MyHeap []int

func (hp MyHeap)Len()int{return len(hp)}
func (hp MyHeap)Less(i int,j int)bool{return hp[i]<hp[j]}
func (hp MyHeap)Swap(i int,j int){hp[i],hp[j]=hp[j],hp[i]}
func (hp *MyHeap)Push(x any){*hp = append(*hp,x.(int))}
func (hp *MyHeap)Pop()any{old:=*hp;n:=len(old);x:=old[n-1];*hp=old[:n-1];return x}

```

> 复杂度分析
时间复杂度：初始化和 findMedian 都是 $O(1)$，addNum 是 $O(logq)$，其中 q 是 addNum 的调用次数。每次操作堆需要 $O(logq)$ 的时间。
空间复杂度：$O(q)$。
> 

## 77.**121. 买卖股票的最佳时机**

每天有2种选择，转移函数分别是 买入的最优解，和卖出的最优解

```go
func maxProfit(prices []int) int {
    // 这一题只能买入卖出一次，状态，持有，
    // 定义dp 数组 dp[i][0] 持有的最大收益，dp[i][1],不持有的最大收益
    dp := make([][]int, len(prices))
    status := make([]int, len(prices) * 2)
    for i := range dp {
        dp[i] = status[:2]
        status = status[2:]
    }

    // 推导递推公式，dp[i][0] = max(dp[i-1][0],-prices[i]) #选择 今天买入 和 今天以前买入 最低价格
    // dp[i][1] = max(prices[i]+dp[i-1][0],dp[i-1][1]) #选择 今天卖出 和 今天以前卖出的最低价

    // 初始化dp函数
    dp[0][0] = -prices[0]
    dp[0][1] = 0

    // 确定遍历顺序
    for i:=1;i<len(prices);i++{
        dp[i][0] = max(dp[i-1][0],-prices[i])
        dp[i][1] = max(dp[i-1][1],prices[i]+dp[i-1][0])
    }
    fmt.Println(dp)
    return max(dp[len(prices)-1][1])
}
```

> 复杂度分析
时间复杂度 O(N) ： 其中 N 为数组 prices 长度。遍历 prices 使用线性时间。
空间复杂度 O(N) ：因为没有做状态压缩，建立2*N的数组
> 

## **78.55. 跳跃游戏**

模拟，判定条件很重要

```go
func canJump(nums []int) bool {
    power:=nums[0]
    step:=0

    for power>0 && step<len(nums)-1{ //限定遍历条件，最后一个值不用访问，
        power-- //每次进入循环 都要 power 减1 
        power = max(nums[step],power) //更新power
        if power>0{ // 只有power 大于 0 时 再往后跳
            step++
        }
    }

    return step == len(nums)-1
}
```

> 复杂度分析
时间复杂度 O(N) ： 最坏情况遍历每一个
空间复杂度 O(1) ：建立有限个变量
> 

## 79.**45. 跳跃游戏 II**

每一步都记录能到达这一个位置的最小值，

```go
func jump(nums []int) int {
    min_jump := make([]int,len(nums))
    
    for i:=1;i<len(nums);i++{
        min_jump[i] = math.MaxInt
    }
    
    for i:=0;i<len(nums);i++{ //遍历 nums[i] 位置
        for j:=1;j+i<len(nums) && j<=nums[i];j++{
            min_jump[i+j] = min(min_jump[i+j],min_jump[i]+1)
        }
    }
    return min_jump[len(min_jump)-1]
}
```

> 复杂度分析
时间复杂度 O(N^2) ： 最糟糕的情况，每个跳跃的长度都非常长，都能调到结尾
空间复杂度 O(N) ：使用另外的数组作为计数辅助
> 

### 进阶解法

和合并区间类似,像搭桥，只有到目前桥的尾部再ans++，nextRight 找遍历过的最大值

```go
func jump(nums []int) (ans int) {
    curRight := 0  // 已建造的桥的右端点
    nextRight := 0 // 下一座桥的右端点的最大值
    for i, num := range nums[:len(nums)-1] {
        nextRight = max(nextRight, i+num)
        if i == curRight { // 到达已建造的桥的右端点
            curRight = nextRight // 造一座桥
            ans++
        }
    }
    return
}

```

> 复杂度分析
时间复杂度 O(N) ： 遍历整个数组
空间复杂度 O(1) ： 只使用有限个变量
> 

## 80.**763. 划分字母区间**

字符最先最后出现的位置，就是左右边界，此题区间合并

```go
func partitionLabels(s string) []int {
    ans := []int{}

    m := map[rune]int{}
    for i,c := range s{ //记录每个字符出现的右边界
        m[c] = i 
    }
    // fmt.Println(m)
    left,right:=0,0
    for i,c := range s{// 遍历字符串
        if m[c] >right{ // 如果遇到字符覆盖范围更广的，扩展右边界
            right = m[c]
        }
        if i == right { //如果成功遍历到了右边界，填入结果
            ans = append(ans,right-left+1)
            left = right +1
        }
    }
    return ans
}
```

> 复杂度分析
时间复杂度：O(n)，其中 n 是字符串的长度。需要遍历字符串两次，第一次遍历时记录每个字母最后一次出现的下标位置，第二次遍历时进行字符串的划分。
空间复杂度：O(∣Σ∣)，其中 Σ 是字符串中的字符集。这道题中，字符串只包含小写字母，因此 ∣Σ∣=26。
> 

## **81.70. 爬楼梯**

斐波那契数列，这一题用dp 解法，

```go
func climbStairs(n int) int {
    
    //初始化dp 数组
    dp := make([]int,n+1)
    // 推到递推公式 dp[i]=dp[i-1]+dp[i-2]
    
    //初始化dp 数组
    dp[0]=1
    dp[1]=1

    //确定遍历顺序
    for i:=2;i<=n;i++{
        dp[i]=dp[i-1]+dp[i-2]
    }
    return dp[n]

}
```

> 复杂度分析
时间复杂度：O(n)。
空间复杂度：O(n)。
> 

## **82.118. 杨辉三角**

动态规划，递推公式 dp[i][j]=dp[i-1][j-1]+dp[i-1][j]

```go
func generate(numRows int) [][]int {
    //确定dp 数组
    dp := make([][]int,numRows)
    //推导递推公式
    // (i<j) dp[i][j]=dp[i-1][j-1]+dp[i-1][j]
    // (j==0 or i==j) dp[i][j]=1

    //初始化 dp数组
    for i:=0;i< numRows ;i++{
        dp[i]= make([]int,i+1)
        dp[i][0]=1
        dp[i][i]=1
    }
    
    //确定遍历顺序
    for i:=1;i<numRows;i++{
        for j:=1;j<i;j++{
            dp[i][j]=dp[i-1][j-1]+dp[i-1][j]
        }
    }

    return dp
}
```

> 复杂度分析
时间复杂度：$O(numRows^2)$。
空间复杂度：$O(1)$。返回值不计入。
> 

## **83.198. 打家劫舍**

正常的dp 递推公式为 

 `dp[i][0] = max(dp[i-1][0],dp[i-1][1]+nums[i])
 dp[i][1] = max(dp[i-1][0],dp[i-1][1])`

```go
func rob(nums []int) int {
    
    //确定dp 数组含义 dp[i][0] 在[0,i]房间内，偷i 房间的最大值，dp[i][1] 不偷最大值
    dp:=make([][2]int,len(nums))  

    //推到递推公式 
    // dp[i][0] = max(dp[i-1][0],dp[i-1][1]+nums[i])
    // dp[i][1] = max(dp[i-1][0],dp[i-1][1]) 

    //初始化dp 数组
    dp[0][0]=nums[0]
    dp[0][1]=0

    //确定遍历顺序
    for i:=1;i<len(nums);i++{
        dp[i][0] = max(dp[i-1][0],dp[i-1][1]+nums[i])
        dp[i][1] = max(dp[i-1][0],dp[i-1][1]) 
    }

    return max(dp[len(nums)-1][0],dp[len(nums)-1][1])
}
```

> 复杂度分析
时间复杂度：O(n)。
空间复杂度：O(n)。可以状态压缩，空间复杂度到常数级
> 

## **84.279. 完全平方数**

```go
func numSquares(n int) int {
    //确定dp 数组的定义 dp[i] 数字 i 是最少几个完全平方数组成的
    dp:= make([]int,n+1)

    //推到递推公式 dp[i]= min(dp[i-j]+dp[j],...) (0<=j<i)

    //初始化dp数组
    for i:=1;i<=n;i++{
        dp[i]=math.MaxInt-1 //为了防止溢出，所以减1
    }
    dp[0]=0

    for i:=1;i<=n;i++{
        for j:=0;j*j <= i;j++{
            dp[i]=min(dp[i],dp[i-j*j]+1)
        }
    }
    return dp[n]
}
```

> 复杂度分析
时间复杂度：$O(n^{3/2})$，其中 n 为给定的正整数。状态转移方程的时间复杂度为 O(n)，共需要计算 n 个状态，因此总时间复杂度为 $O(n^{3/2})$。
空间复杂度：$O(n)$。我们需要 $O(n)$ 的空间保存状态。
> 

## *85.**322. 零钱兑换**

一个维度就可以了，二维也可以，

```go
func coinChange(coins []int, amount int) int {

    //确定dp数组定义 dp[j] 背包容量是j 的最小数字
    dp := make([]int,amount+1)
    

    /*
    推到递推公式
    dp[j] = min(dp[j],dp[j-coins[i]]+1)
    */

    //初始化dp数组
    dp[0] = 0
    for i:=1;i<=amount;i++{
        dp[i]=math.MaxInt-1
    }

    // 确定遍历顺序
    // 外层遍历物品，内层遍历背包，(组合数),顺序遍历(完全背包)
    // 外层遍历背包，内层遍历物品，(排列数),逆序遍历(01背包)
    for i:=0;i<len(coins);i++{
        for j :=0;j<=amount;j++{
            if j >= coins[i]{
                dp[j]=min(dp[j],dp[j-coins[i]]+1)
            }
        }
    }
    
    if dp[amount] == math.MaxInt -1{
        return -1
    }else{
        return dp[amount] 
    }
}
```

> 复杂度分析
时间复杂度：$O(Sn)$，其中 S 是金额，n 是面额数。我们一共需要计算 O(S) 个状态，S 为题目所给的总金额。对于每个状态，每次需要枚举 n 个面额来转移状态，所以一共需要 O(Sn) 的时间复杂度。
空间复杂度：$O(S)$。数组 dp 需要开长度为总金额 S 的空间。
> 

### 二维dp 实现

### 递推公式

对于每个硬币 `i`（从 `1` 到 `n`）和每个容量 `j`（从 `0` 到 `amount`），递推公式如下：

1. **如果不选择第 `i` 个硬币**，则`dp[i][j]` 值将等于 **前 `i-1` 个硬币**组成 `j` 的最小硬币数，即 `dp[i-1][j]`。
2. **如果选择第 `i` 个硬币**，则`dp[i][j]` 值将等于 `dp[i][j-coins[i-1]] + 1`，其中 `coins[i-1]` 是当前物品的硬币面额，表示选择该硬币后剩余的金额。

综合以上两种情况，递推公式为：

$$
dp[i][j]=min(dp[i−1][j],dp[i][j−coins[i−1]]+1)
$$

```go
func coinChange(coins []int, amount int) int {
    // dp[i][j] 表示前 i 个硬币组成 j 金额所需的最少硬币数
    dp := make([][]int, len(coins)+1)
    for i := range dp {
        dp[i] = make([]int, amount+1)
    }

    // 初始化 dp 数组
    for i := 0; i <= len(coins); i++ {
        dp[i][0] = 0 // 背包容量为 0 时，所需硬币数为 0
    }
    for j := 1; j <= amount; j++ {
        dp[0][j] = math.MaxInt - 1 // 初始化为一个很大的数，表示无法组成
    }

    // 填充 dp 数组
    for i := 1; i <= len(coins); i++ {
        for j := 1; j <= amount; j++ {
            // 如果不选择当前硬币
            dp[i][j] = dp[i-1][j]

            // 如果选择当前硬币，且剩余金额不小于当前硬币的面额
            if j >= coins[i-1] {
                dp[i][j] = min(dp[i][j], dp[i][j-coins[i-1]] + 1)
            }
        }
    }

    if dp[len(coins)][amount] == math.MaxInt-1 {
        return -1
    }
    return dp[len(coins)][amount]
}

```

## 86.**139. 单词拆分**

标记为1 是在这个单词的**后边**标记为1 s截取范围 `[j,i)` 标记位置 `dp[i]`

递推公式，

$$
dp[i]=True if (dp[j]=True and s[j:i]∈wordDictSet) for some 0≤j<i
$$

```go
func wordBreak(s string,wordDict []string) bool  {
	//建立一个字典 产看元素是否在其中
    wordDictSet := make(map[string]bool)
	for _, w := range wordDict {
		wordDictSet[w] = true
	}

    //确定dp 数组
	dp := make([]bool, len(s)+1)
    //递推公式
    //dp[i]=True if (dp[j]=True and s[j:i]∈wordDictSet) for some 0≤j<i

    //初始化dp 数组
	dp[0] = true

    //确定遍历顺序，先容量，再物品，正序
	for i := 1; i <= len(s); i++ { // i 用于遍历数组
		for j := 0; j < i; j++ { // j 和i 组成双指针，用于遍历 s[j:i] 是否在 wordDictSet 中
            
			if dp[j] && wordDictSet[s[j:i]] { // 状态转移方程
				dp[i] = true   
				break
			}
		}
	}
	return dp[len(s)]
}
```

> 复杂度分析
时间复杂度：$O(n^2)$，其中 n 是字符串 s 的长度。
空间复杂度：$O(n + m * k)$，其中 m 是字典中单词的数量，k 是字典中单词的平均长度。
> 

## 87.**300. 最长递增子序列**

最后要用 ans 收集一下最大值

递推公式

$$
dp[i]=max(dp[i],dp[j]+1)if nums[j]<nums[i]for j<i
$$

```go
func lengthOfLIS(nums []int) int {
    
    ans:=0

    //确定dp数组 dp[i][1]在到第i位时候，选择第i位置的最大长度，dp[i][0] 不选第i 位最大长度
    dp:=make([]int,len(nums))

    // 递推公式
    // dp[i] = max(dp[j] if nums[j] < nums[i])

    //初始化dp数组
    for i:=range dp{
        dp[i]=1
    }

    //初始化遍历顺序
    for i:=0;i<len(nums);i++{
        for j:=0;j<i;j++{
            if nums[j] < nums[i]{
                dp[i] = max(dp[i],dp[j]+1)
            }
        }
        ans = max(ans,dp[i])
    }

    return ans
}
```

> 复杂度分析
时间复杂度：$O(n^2)$，因为有嵌套的两层循环。
空间复杂度：$O(n)$，因为需要存储 dp 数组。
> 

## 88.**152. 乘积最大子数组**

本题 x=nums[i], 如果 x>0   找最大的$dp_{max}[i]$ 如果 x<0 找最小的 $dp_{min}[i]$ (尽可能绝对值大的负数)

$$
f_{max} [i]=max(f_{max} [i−1]⋅x,f_{min}[i−1]⋅x,x) \\
f_{min} [i]=min(f_{max} [i−1]⋅x,f_{min}[i−1]⋅x,x)
$$

```go
func maxProduct(nums []int) int {
    //定义dp数组 dp[i][0] 以 nums[i]结尾的最大值，dp[i][1]以为 nums[i]结尾的最小值
    dp:= make([][2]int,len(nums))

    //推导 递推公式
    /*
    dp[i][0] = max(dp[i-1][0]*nums[i],dp[i-1][1]*nums[i],nums[i])
    dp[i][1] = min(dp[i-1][0]*nums[i],dp[i-1][1]*nums[i],nums[i])
    */

    //初始化dp数组
    ans:=nums[0]
    dp[0][0]=nums[0]
    dp[0][1]=nums[0]

    //确定遍历顺序
    for i:=1;i<len(nums);i++{
        dp[i][0] = max(dp[i-1][0]*nums[i],dp[i-1][1]*nums[i],nums[i])
        dp[i][1] = min(dp[i-1][0]*nums[i],dp[i-1][1]*nums[i],nums[i])
        ans = max(ans,dp[i][0])
    }
    return ans
}
```

> 复杂度分析
时间复杂度：O(n)，因为遍历一次。
空间复杂度：O(n)，因为需要存储 dp 数组。
> 

## 89.**416. 分割等和子集**

将总量一分为2，变成01背包问题，选或者不选，最后刚好等于 cap(sumNums/2)

$$
dp[i][j] =
\begin{cases} 
\max(dp[i-1][j], dp[i-1][j-\text{nums}[i]]), & \text{if } j \geq \text{nums}[i] \\
dp[i-1][j], & \text{if } j < \text{nums}[i]
\end{cases}
$$

```go
func canPartition(nums []int) bool {
    nums_sum:=0
    for _,v:=range nums{
        nums_sum+=v
    }
    if nums_sum%2!=0{
        return false
    }
    cap:= nums_sum/2

    //初始化dp数组 dp[i][j] 容量为j 在选择 [0,i]号元素的时候，最大值
    dp := make([][]int,len(nums))
    for i,_:=range nums{
        dp[i]=make([]int,cap+1)
    }

    //推导递推公式
    /*
    dp[i][j] = max(dp[i-1][j-nums[i]]+nums[i],dp[i-1][j])
    dp[i][j] = dp[i-1][j]
    */

    //初始化dp数组
    dp[0][0]=0
    for j:=nums[0];j<=cap;j++{
        dp[0][j]=nums[0]
    }

    //确定遍历顺序
    for i:=1;i<len(nums);i++{
        for j :=1;j<=cap;j++{
            if j>=nums[i]{
                dp[i][j] = max(dp[i-1][j-nums[i]]+nums[i],dp[i-1][j])
            }else{
                dp[i][j] = dp[i-1][j]
            }
        }
    }
    // fmt.Println(dp)

    return dp[len(nums)-1][cap]==cap
}
```

> 复杂度分析
时间复杂度：$O(n*cap)$，每个节点遍历一遍。
**空间复杂度：$O(n*cap)$，存储每一个的状态。
> 

## 90.**32. 最长有效括号**

关键点，检查位置，检查是否超过

```go
    //推导递推公式
    /*
    '()' dp[i]=dp[i-2]+2
    '(())' dp[i] = dp[i-1]+2 +dp[i-dp[i-1]-2]
    */
```

```go
func longestValidParentheses(s string) int {
    if len(s)==0{
        return 0
    }
    ans:=0
    // 定义dp数组 dp[i] 以 i 结尾的最后一个数字
    dp:= make([]int,len(s))

    //推导递推公式
    /*
    '()' dp[i]=dp[i-2]+2
    '(())' dp[i] = dp[i-1]+2 +dp[i-dp[i-1]-2]
    */

    //初始化dp数组
    dp[0] = 0
    //确定遍历顺序

    for i:=1;i<len(s);i++{
        if s[i]==')'{
            if s[i-1]=='('{ //已经闭合的情况
                if i-2>=0{ //如果前面有元素
                    dp[i]=dp[i-2]+2
                }else{
                    dp[i]=2
                }
            }else if i - dp[i-1]-1 >=0 && s[i - dp[i-1]-1]=='('{ //未闭合并且 前面 合法位置有括号
                if i-dp[i-1]-2 >=0{ // 前面有 元素
                    dp[i] = dp[i-1]+2 +dp[i-dp[i-1]-2]
                }else{ 
                    dp[i] = dp[i-1]+2
                }
            }
        }
        ans =max(ans,dp[i])
    }
    return ans
}
```

> 复杂度分析
时间复杂度： $O(n)$，其中 n 为字符串的长度。我们只需遍历整个字符串一次，即可将 dp 数组求出来。
空间复杂度： $O(n)$。我们需要一个大小为 n 的 dp 数组。
> 

## **91.62. 不同路径**

状态转移方程比较简单

$$
dp[i][j]=dp[i-1][j]+dp[i][j-1]
$$

```go
func uniquePaths(m int, n int) int {
    
    //确定dp数组 dp[i][j] 到达i,j 位置有多少条路
    dp:=make([][]int,m)
    for i:=0;i<m;i++{
        dp[i]=make([]int,n)
    }

    //确定遍历顺序，dp[i][j]=dp[i-1][j]+dp[i][j-1]

    //初始化dp数组
    for i:=0;i<m;i++{
        dp[i][0]=1
    }
    for j:=0;j<n;j++{
        dp[0][j]=1
    }

    //确定遍历顺序
    
    for i:=1;i<m;i++{
        for j:=1;j<n;j++{
            dp[i][j]=dp[i-1][j]+dp[i][j-1]
        }
    }
    return dp[m-1][n-1]
}
```

> 复杂度分析
时间复杂度：O(mn)。
空间复杂度：O(mn)，
> 

## **92.64. 最小路径和**

简单的dp，递推公式很好推导

递推公式

$$
dp[i][j] = \text{grid}[i][j]+ min(dp[i-1][j],dp[i][j-1])
$$

```go
func minPathSum(grid [][]int) int {
    m,n:= len(grid),len(grid[0])
    //定义dp数组 dp[i][j] 到达 i,j 位置的最小值
    dp:= make([][]int,m)
    for i:=0;i<m;i++{
        dp[i] = make([]int,n)
    }

    // 推导递推公式 dp[i][j] = grid[i][j]+ min(dp[i-1][j],dp[i][j-1])
    
    // 初始化 数组
    dp[0][0]=grid[0][0]
    for i:=1;i<m;i++{
        dp[i][0]=grid[i][0]+dp[i-1][0]
    }
    for j:=1;j<n;j++{
        dp[0][j]=grid[0][j]+dp[0][j-1]
    }

    //确定 遍历顺序
    for i:=1;i<m;i++{
        for j:=1;j<n;j++{
            dp[i][j] = grid[i][j]+ min(dp[i-1][j],dp[i][j-1])
        }
    }
    return dp[m-1][n-1]
}
```

> 复杂度分析
时间复杂度：O(m * n)
空间复杂度：O(m * n)
> 

## **93.5. 最长回文子串**

只有右上角有数字的对角矩阵，状态根据左下而来，所以要从右下角开始一层一层往上遍历

递推公式

$$
 dp[i][j] = (j-i==1\ \text{or} \ dp[i+1][j-1]) \ \text{and} \ s[i]==s[j] \ (i<j)
$$

```go
func longestPalindrome(s string) string {
    ans:= s[0:1]
    //定义dp数组 dp[i][j] 字符串s[i,j]是不是回文 (i<j)
    dp := make([][]bool,len(s))
    for i:=0;i<len(s);i++{
        dp[i]=make([]bool,len(s))
    }

    // 推导递推公式 dp[i][j] = (j-i==1||dp[i+1][j-1]) && s[i]==s[j] (i<j)

    //初始化 dp数组
    for i:=0 ;i<len(s);i++{
        dp[i][i]=true
    }

    //确定遍历顺序
    for i:=len(s)-1;i>=0;i--{
        for j:=i+1;j<len(s);j++{
            dp[i][j] = (j-i==1||dp[i+1][j-1]) && s[i]==s[j]
            if dp[i][j] && j-i+1 > len(ans){ //
                ans = s[i:j+1]
            }
        }
    }
    return ans
}
```

> 复杂度分析
时间复杂度：O(n^2)，其中 n 是字符串 s 的长度。
空间复杂度：O(n^2)，其中 n 是字符串 s 的长度。
> 

## **94.1143. 最长公共子序列**

因为是不连续的，递推公式稍微复杂一点，递归边界多加一行，就是为了初始条件简单

$$
dp[i][j] = 
\begin{cases}
dp[i-1][j-1] + 1 & \text{如果} \, text1[i-1] = text2[j-1] \\
\max(dp[i-1][j], dp[i][j-1]) & \text{如果} \, text1[i-1] \neq text2[j-1]
\end{cases}
$$

```go
func longestCommonSubsequence(text1 string, text2 string) int {
    ans :=0
    m,n:=len(text1),len(text2)
    //定义dp数组 dp[i][j] text1 以 i 结尾 和 text2 以 j 为结尾 最长的子序列
    dp:= make([][]int,m+1)
    for i:=0;i<m+1;i++{
        dp[i]=make([]int,n+1)
    }
    // 推导递推公式
    /*
    dp[i][j] =  dp[i-1][j-1]+ 1 text1[i] == text2[j]
    dp[i][j] =  dp[i-1][j-1] text1[i] != text2[j]
    */

    //初始化dp数组
    dp[0][0]=0

    //遍历数组
    for i:=1;i<=m;i++{
        for j:=1;j<=n;j++{
            if text1[i-1] == text2[j-1] {
                dp[i][j] =  dp[i-1][j-1]+ 1
            }else{
                dp[i][j] = max(dp[i-1][j],dp[i][j-1])
            }
        }   
    }
    return dp[m][n]
}
```

> **复杂度分析**
**时间复杂度**：$O(m \times n)$，其中 m 和 n 分别是 text1 和 text2 的长度。我们需要遍历整个 dp 数组，执行 m * n 次操作，每次操作是常数时间。
**空间复杂度**：$O(m \times n)$，我们使用了一个大小为 (m+1) x (n+1) 的二维数组来存储中间结果。
> 

## **95.72. 编辑距离**

为什么不是 max(m,n)-最长公共子序列 ，因为 有些地方可以替换，有些必须先删除后插入，结尾2个字一样，不用管，不一样的话，可以增删改+1

$$
dp[i][j] = \begin{cases}
dp[i-1][j-1] & \text{if } word1[i-1] = word2[j-1] \\
\min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1 & \text{if } word1[i-1] \neq word2[j-1]
\end{cases}
$$

```go
func minDistance(word1 string, word2 string) int {
    m,n:=len(word1),len(word2)
    //确定dp 公式 dp[i][j] 小于i,j 最长子序列
    dp:= make([][]int,m+1)
    for i:=0;i<m+1;i++{
        dp[i]=make([]int,n+1)
    }
    /*递推公式 相等不用管，不相等，min(增删改)+1
    dp[i][j] = dp[i-1][j-1] if word1[i-1]==word2[j-1]
    dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1 if word1[i-1]!=word2[j-1]
    */

    //初始化dp数组	
    for i := 0; i < m+1; i++ {
		dp[i][0] = i // word1[i] 变成 word2[0], 删掉 word1[i], 需要 i 部操作
	}
	for j := 0; j < n+1; j++ {
		dp[0][j] = j // word1[0] 变成 word2[j], 插入 word1[j]，需要 j 部操作
	}

    //确定遍历顺序
    for i:=1;i<=m;i++{
        for j:=1;j<=n;j++{
            if word1[i-1]==word2[j-1]{
                dp[i][j] = dp[i-1][j-1]
            }else{
                dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1
            }
        }
    }
    return dp[m][n]
}
```

> **复杂度分析**
**时间复杂度**：$O(m \times n)$，其中 m 和 n 是 word1 和 word2 的长度。我们需要填充一个大小为 (m+1) x (n+1) 的二维 dp 数组，每个元素的计算时间为常数。
**空间复杂度**：$O(m \times n)$，我们使用了一个二维 dp 数组来存储每个子问题的解。
> 

## **96.136. 只出现一次的数字**

位运算符，异或 a^0==a    a^a==0

```go
func singleNumber(nums []int) int {
    single :=0 
    for _,num := range nums{
        single ^= num
    }
    return single
}
```

> 复杂度分析
时间复杂度：O(n)，其中 n 是数组 nums 的长度。我们遍历数组一次，每次操作是常数时间。
空间复杂度：O(1)，因为只用了常数空间来存储 single 变量。
> 

## 97.**169. 多数元素**

Boyer-Moore投票，找候选人，如果遇到相同count++，否则count— ,到0时交换，最后一定是超过半数的

```go
func majorityElement(nums []int) int {
    count:=0
    candidate := nums[0]
    for _,v:=range nums{
        if count==0{
            candidate=v
        }
        if candidate == v{
            count++
        }else{
            count--
        }
    }
    return candidate
}
```

> 复杂度分析
时间复杂度： O(n)，因为我们只遍历了数组一次。
空间复杂度： O(1)，因为我们只使用了常数的额外空间。
> 

## 98.**75. 颜色分类**

单指针，先放0在前面，然后放1在前面

```go
func sortColors(nums []int) {
    n:=len(nums)
    ptr := 0
    for i:=0;i<n;i++{// 把全部的0放在头部，
        if nums[i]==0{
            nums[i],nums[ptr] = nums[ptr],nums[i]
            ptr += 1
        }
    }
    for i:=ptr;i<n;i++{ //把全部的1放在 0的后面
        if nums[i] == 1{
            nums[i],nums[ptr] = nums[ptr],nums[i]
            ptr += 1
        }
    }
}

```

> 复杂度分析
时间复杂度： O(n)，因为我们只遍历了数组一次。
空间复杂度： O(1)，因为我们只使用了常数的额外空间。
> 

## **99.31. 下一个排列**

从右往左，先找第一个连续的升序，然后找到第一个大于升序中较小的元素，交换，然后逆序排列较小元素之后的元素

```go
func nextPermutation(nums []int) {
	if len(nums) <= 1 {
		return
	}

	i, j, k := len(nums)-2, len(nums)-1, len(nums)-1

	// find: A[i]<A[j] 从后往前找第一个 2位 连续的升序数字
	for i >= 0 && nums[i] >= nums[j] {
		i--
		j--
	}

	if i >= 0 { // 如果找到了 
		// find: A[i]<A[k] 从后往前找，第一个大于 A[i]的 
		for nums[i] >= nums[k] {
			k--
		}
		// swap A[i], A[k] 交换顺序
		nums[i], nums[k] = nums[k], nums[i]
	}

	// reverse A[j:end] 把i之后的翻转，从降序变为升序
	for l, r := j, len(nums)-1; l < r; l, r = l+1, r-1 {
		nums[l], nums[r] = nums[r], nums[l]
	}
}
```

> **复杂度分析**
**时间复杂度**：$O(n)$，其中 n 是数组的长度。由于需要扫描数组几次，整体时间复杂度为线性。
**空间复杂度**：$O(1)$，只使用了常数空间，没有使用额外的存储空间。
> 

## 100.**287. 寻找重复数**

和找到链表中的环类似，快慢指针相遇，然后两者速度相同，慢指针在头部，从新相遇就是

```go
func findDuplicate(nums []int) int {
    fast,slow:=0,0
    for true{ // 双指针 找 环 
        fast,slow=nums[nums[fast]],nums[slow]
        if fast==slow{break}
    }
    slow = 0 //找到环所在的位置 
    for slow != fast {
        slow = nums[slow]
        fast = nums[fast]
    }
    return slow
}
```

> 复杂度分析
时间复杂度：O(n)，其中 n 是数组的长度。通过快慢指针，我们在最坏情况下需要遍历整个数组，时间复杂度是线性的。
空间复杂度：O(1)，因为只使用了常数空间（两个指针）。